## 有一个网络请求接口，放在主线程调用还是子线程调用

**面试回答要点：**
网络请求本身是异步操作，但发起请求的代码通常在主线程执行。真正的网络IO由浏览器底层处理。

**技术分析：**
```javascript
// 主线程发起请求（推荐）
class MainThreadRequest {
  async fetchData() {
    try {
      // 请求发起在主线程，但不会阻塞
      const response = await fetch('/api/data');
      const data = await response.json();
      
      // 可以直接操作DOM
      document.getElementById('result').textContent = data.message;
      return data;
    } catch (error) {
      console.error('请求失败:', error);
    }
  }
}

// Web Worker中发起请求（特殊场景）
// main.js
const worker = new Worker('request-worker.js');
worker.postMessage({ url: '/api/data' });
worker.onmessage = (event) => {
  const data = event.data;
  document.getElementById('result').textContent = data.message;
};

// request-worker.js
self.onmessage = async (event) => {
  const { url } = event.data;
  try {
    const response = await fetch(url);
    const data = await response.json();
    self.postMessage(data);
  } catch (error) {
    self.postMessage({ error: error.message });
  }
};
```

**选择原则：**
- **主线程**：适合大多数场景，可直接操作DOM，代码简单
- **Web Worker**：适合大量并发请求、复杂数据处理、避免阻塞UI的场景

## 一个页面上有大量图片和视频怎么左右滑

**面试回答要点：**
通过虚拟滚动、懒加载、预加载等技术优化大量媒体资源的滑动体验。

**核心实现：**
```javascript
class MediaSlider {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      itemWidth: 300,
      visibleCount: 3,
      preloadCount: 2,
      ...options
    };
    
    this.currentIndex = 0;
    this.mediaItems = [];
    this.renderedItems = new Map();
    
    this.init();
  }
  
  init() {
    this.setupHTML();
    this.bindEvents();
    this.render();
  }
  
  setupHTML() {
    this.container.innerHTML = `
      <div class="slider-wrapper">
        <div class="slider-track"></div>
      </div>
      <button class="prev-btn">‹</button>
      <button class="next-btn">›</button>
    `;
    
    this.track = this.container.querySelector('.slider-track');
    this.prevBtn = this.container.querySelector('.prev-btn');
    this.nextBtn = this.container.querySelector('.next-btn');
  }
  
  bindEvents() {
    // 触摸滑动
    let startX = 0;
    let currentX = 0;
    let isDragging = false;
    
    this.track.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      isDragging = true;
    });
    
    this.track.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      
      currentX = e.touches[0].clientX;
      const deltaX = currentX - startX;
      
      // 实时更新位置
      this.updatePosition(deltaX);
    });
    
    this.track.addEventListener('touchend', (e) => {
      if (!isDragging) return;
      
      const deltaX = currentX - startX;
      const threshold = this.options.itemWidth / 3;
      
      if (Math.abs(deltaX) > threshold) {
        if (deltaX > 0) {
          this.prev();
        } else {
          this.next();
        }
      } else {
        this.snapToPosition();
      }
      
      isDragging = false;
    });
    
    // 按钮点击
    this.prevBtn.addEventListener('click', () => this.prev());
    this.nextBtn.addEventListener('click', () => this.next());
  }
  
  // 虚拟滚动渲染
  render() {
    const startIndex = Math.max(0, this.currentIndex - this.options.preloadCount);
    const endIndex = Math.min(
      this.mediaItems.length - 1,
      this.currentIndex + this.options.visibleCount + this.options.preloadCount
    );
    
    // 清理不需要的元素
    this.cleanupItems(startIndex, endIndex);
    
    // 渲染需要的元素
    for (let i = startIndex; i <= endIndex; i++) {
      if (!this.renderedItems.has(i)) {
        this.renderItem(i);
      }
    }
    
    this.updatePosition();
  }
  
  renderItem(index) {
    const item = this.mediaItems[index];
    if (!item) return;
    
    const element = document.createElement('div');
    element.className = 'slider-item';
    element.style.transform = `translateX(${index * this.options.itemWidth}px)`;
    
    if (item.type === 'image') {
      element.innerHTML = `
        <img 
          src="${item.placeholder}" 
          data-src="${item.src}" 
          alt="${item.alt}"
          loading="lazy"
          class="media-image"
        />
      `;
      
      // 懒加载图片
      this.lazyLoadImage(element.querySelector('img'));
    } else if (item.type === 'video') {
      element.innerHTML = `
        <video 
          poster="${item.poster}"
          preload="none"
          controls
          class="media-video"
        >
          <source data-src="${item.src}" type="${item.mimeType}">
        </video>
      `;
      
      // 懒加载视频
      this.lazyLoadVideo(element.querySelector('video'));
    }
    
    this.track.appendChild(element);
    this.renderedItems.set(index, element);
  }
  
  lazyLoadImage(img) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const image = entry.target;
          image.src = image.dataset.src;
          image.onload = () => {
            image.classList.add('loaded');
          };
          observer.unobserve(image);
        }
      });
    });
    
    observer.observe(img);
  }
  
  lazyLoadVideo(video) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const source = video.querySelector('source');
          source.src = source.dataset.src;
          video.load();
          observer.unobserve(video);
        }
      });
    });
    
    observer.observe(video);
  }
  
  next() {
    if (this.currentIndex < this.mediaItems.length - this.options.visibleCount) {
      this.currentIndex++;
      this.render();
    }
  }
  
  prev() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.render();
    }
  }
  
  updatePosition(offset = 0) {
    const translateX = -this.currentIndex * this.options.itemWidth + offset;
    this.track.style.transform = `translateX(${translateX}px)`;
  }
}
```

**性能优化策略：**
- **虚拟滚动**：只渲染可见区域的元素
- **懒加载**：图片和视频按需加载
- **预加载**：提前加载下一屏内容
- **缓存机制**：已加载的资源进行缓存

## 图片或视频请求失败怎么做重试

**面试回答要点：**
实现指数退避重试机制，区分不同错误类型，设置合理的重试策略。

**重试机制实现：**
```javascript
class MediaRetryManager {
  constructor(options = {}) {
    this.options = {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      backoffFactor: 2,
      retryableErrors: [408, 429, 500, 502, 503, 504],
      ...options
    };
  }
  
  async loadImage(src, retryCount = 0) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => resolve(img);
      
      img.onerror = async () => {
        if (retryCount < this.options.maxRetries) {
          console.log(`图片加载失败，第${retryCount + 1}次重试:`, src);
          
          // 计算延迟时间（指数退避）
          const delay = Math.min(
            this.options.baseDelay * Math.pow(this.options.backoffFactor, retryCount),
            this.options.maxDelay
          );
          
          // 添加随机抖动，避免惊群效应
          const jitterDelay = delay + Math.random() * 1000;
          
          setTimeout(async () => {
            try {
              const result = await this.loadImage(src, retryCount + 1);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          }, jitterDelay);
        } else {
          // 重试次数用完，使用备用图片
          this.loadFallbackImage(src).then(resolve).catch(reject);
        }
      };
      
      img.src = src;
    });
  }
  
  async loadVideo(src, retryCount = 0) {
    try {
      const response = await fetch(src, {
        method: 'HEAD' // 先检查资源是否存在
      });
      
      if (response.ok) {
        return src;
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      if (retryCount < this.options.maxRetries && this.shouldRetry(error)) {
        console.log(`视频检查失败，第${retryCount + 1}次重试:`, src);
        
        const delay = this.calculateDelay(retryCount);
        await this.sleep(delay);
        
        return this.loadVideo(src, retryCount + 1);
      } else {
        // 返回备用视频或占位符
        return this.getFallbackVideo(src);
      }
    }
  }
  
  shouldRetry(error) {
    // 网络错误
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      return true;
    }
    
    // HTTP状态码错误
    if (error.message.includes('HTTP')) {
      const statusCode = parseInt(error.message.match(/\d+/)[0]);
      return this.options.retryableErrors.includes(statusCode);
    }
    
    return false;
  }
  
  calculateDelay(retryCount) {
    const delay = Math.min(
      this.options.baseDelay * Math.pow(this.options.backoffFactor, retryCount),
      this.options.maxDelay
    );
    
    // 添加随机抖动
    return delay + Math.random() * 1000;
  }
  
  async loadFallbackImage(originalSrc) {
    // 尝试不同的备用策略
    const fallbackStrategies = [
      () => this.loadFromCDN(originalSrc),
      () => this.loadFromCache(originalSrc),
      () => this.loadPlaceholder('image'),
      () => this.generatePlaceholder(originalSrc)
    ];
    
    for (const strategy of fallbackStrategies) {
      try {
        const result = await strategy();
        if (result) return result;
      } catch (error) {
        console.warn('备用策略失败:', error);
      }
    }
    
    throw new Error('所有备用策略都失败了');
  }
  
  async loadFromCDN(originalSrc) {
    // 尝试从备用CDN加载
    const cdnUrls = [
      originalSrc.replace('cdn1.example.com', 'cdn2.example.com'),
      originalSrc.replace('cdn1.example.com', 'cdn3.example.com')
    ];
    
    for (const url of cdnUrls) {
      try {
        return await this.loadImage(url, 0);
      } catch (error) {
        continue;
      }
    }
    
    throw new Error('CDN备用加载失败');
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// 使用示例
const retryManager = new MediaRetryManager();

// 加载图片
retryManager.loadImage('/api/images/photo.jpg')
  .then(img => {
    document.body.appendChild(img);
  })
  .catch(error => {
    console.error('最终加载失败:', error);
  });
```

## 性能优化案例（首屏加载、资源压缩、CDN策略等）

**面试回答要点：**
从资源优化、加载策略、缓存机制、代码分割等多个维度进行首屏性能优化。

**核心优化策略：**
- **资源预加载优化**：DNS预解析、预连接、预加载关键资源
- **图片优化**：现代格式、响应式图片、懒加载  
- **代码分割**：按需加载、动态导入
- **缓存策略**：Service Worker、强缓存配置
- **性能监控**：Core Web Vitals指标跟踪

## 在网页中怎么发一个接口请求

**面试回答要点：**
现代浏览器中有多种方式发起HTTP请求，主要包括fetch、XMLHttpRequest、以及各种封装库。

**主要方法对比：**
```javascript
// 1. Fetch API（推荐）
async function fetchData() {
  try {
    const response = await fetch('/api/data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
      },
      body: JSON.stringify({ key: 'value' })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('请求失败:', error);
  }
}

// 2. XMLHttpRequest（传统方式）
function xmlHttpRequest() {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', '/api/data', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(new Error(`HTTP ${xhr.status}`));
        }
      }
    };
    
    xhr.send(JSON.stringify({ key: 'value' }));
  });
}

// 3. Axios（第三方库）
import axios from 'axios';

async function axiosRequest() {
  try {
    const response = await axios.post('/api/data', 
      { key: 'value' },
      {
        headers: {
          'Authorization': 'Bearer token123'
        },
        timeout: 5000
      }
    );
    
    return response.data;
  } catch (error) {
    console.error('请求失败:', error.response?.data || error.message);
  }
}
```

**选择建议：**
- **Fetch**：现代标准，Promise支持，功能完整
- **XMLHttpRequest**：兼容性最好，支持进度监控
- **Axios**：功能丰富，拦截器支持，错误处理完善

## url到页面构建的过程中，中间的白屏和首屏加载如何优化

**面试回答要点：**
从DNS解析到页面渲染的完整链路进行优化，重点解决白屏和首屏加载问题。

**白屏优化策略：**
1. **服务端渲染（SSR）**：预渲染HTML内容
2. **骨架屏**：显示页面结构占位
3. **关键CSS内联**：避免CSS阻塞渲染
4. **资源预加载**：提前获取关键资源
5. **代码分割**：减少初始包大小

## monorepo相较于multirepo的好处，monorepo各种解决方案的区别，为啥不用npm workspace

**面试回答要点：**
Monorepo在代码共享、依赖管理、构建效率等方面有优势，但需要选择合适的工具链。

**主流解决方案对比：**
- **Lerna**：成熟稳定，版本管理强
- **Nx**：性能优秀，功能丰富
- **Rush**：企业级，配置灵活
- **Turborepo**：性能极佳，配置简单
- **npm workspaces**：原生支持，功能基础

**不只用npm workspace的原因：**
1. **功能限制**：只提供基础依赖管理
2. **性能问题**：没有智能缓存和增量构建
3. **工具集成**：缺少测试、lint、发布等集成
4. **可视化支持**：没有依赖图和分析工具

## 给定一个状态为 fulfilled 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise P3 时，新的 Promise P2 的状态和值分别是什么？

**面试回答要点：**
Promise的then方法会根据回调函数的执行结果创建新的Promise。

**详细分析：**
```javascript
const P1 = Promise.resolve('initial value');

// 情况1：正常返回值
const P2_1 = P1.then(value => 'new value');
// 结果：P2_1状态为fulfilled，值为'new value'

// 情况2：抛出错误
const P2_2 = P1.then(value => {
  throw new Error('something went wrong');
});
// 结果：P2_2状态为rejected，原因为Error('something went wrong')

// 情况3：返回null
const P2_3 = P1.then(value => null);
// 结果：P2_3状态为fulfilled，值为null

// 情况4：返回新的Promise P3
const P3 = Promise.resolve('P3 value');
const P2_4 = P1.then(value => P3);
// 结果：P2_4的状态和值取决于P3，即fulfilled，值为'P3 value'
```

## 给定一个状态为 rejected 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise 时，新的 Promise P2 的状态和值/原因分别是什么？

**面试回答要点：**
rejected状态的Promise在then中如果没有提供onRejected回调，会直接传递rejection。

**详细分析：**
```javascript
const P1 = Promise.reject('initial error');

// 情况1：只提供onFulfilled（不会执行）
const P2_1 = P1.then(value => 'new value');
// 结果：P2_1状态为rejected，原因为'initial error'（rejection穿透）

// 情况2：提供onRejected，正常返回
const P2_2 = P1.then(null, error => 'handled error');
// 结果：P2_2状态为fulfilled，值为'handled error'

// 情况3：提供onRejected，抛出新错误
const P2_3 = P1.then(null, error => {
  throw new Error('new error');
});
// 结果：P2_3状态为rejected，原因为Error('new error')

// 情况4：提供onRejected，返回null
const P2_4 = P1.then(null, error => null);
// 结果：P2_4状态为fulfilled，值为null
```

## 如果用户操作总是有弹窗显示失败，咋排查问题?如果是线上环境呢?

**面试回答要点：**
系统化排查问题，从前端到后端，建立完整的监控和调试体系。

**排查步骤：**
1. **前端排查**：检查控制台错误、网络请求、本地存储
2. **网络排查**：检查API状态、网络连接、代理设置  
3. **后端排查**：查看服务器日志、数据库连接、第三方服务
4. **环境排查**：对比不同环境、浏览器兼容性
5. **用户行为分析**：重现操作路径、分析使用模式

**线上环境专用工具：**
- **远程日志收集**：实时错误监控
- **用户会话录制**：重现问题场景
- **性能监控**：识别性能瓶颈
- **A/B测试**：对比不同版本表现

## 一个微任务递归地生成另一个微任务，会陷入死循环吗？

**面试回答要点：**
不会陷入传统意义的死循环，但会导致微任务队列饱和，阻塞其他任务执行。浏览器有保护机制。

**技术分析：**
```javascript
// 微任务递归示例
function createRecursiveMicrotask() {
  console.log('执行微任务');
  
  // 递归创建新的微任务
  Promise.resolve().then(() => {
    createRecursiveMicrotask();
  });
}

// 测试代码
console.log('开始');
createRecursiveMicrotask();
console.log('结束'); // 这行会执行

// 宏任务测试  
setTimeout(() => {
  console.log('宏任务执行'); // 这行可能不会执行
}, 0);
```

**关键要点：**
1. **不会死循环**：浏览器会在适当时机让出执行权
2. **会阻塞宏任务**：微任务队列优先级更高
3. **浏览器有保护**：长时间运行会被限制或警告
4. **影响用户体验**：可能导致页面卡顿或无响应
5. **调试困难**：可能导致开发者工具卡死
