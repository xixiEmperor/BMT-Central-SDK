## 有一个网络请求接口，放在主线程调用还是子线程调用

**核心理论：**
网络请求涉及浏览器的多层架构：JavaScript引擎层、浏览器API层、网络进程层。理解这些层次对选择执行环境至关重要。

**底层机制分析：**

1. **主线程网络请求机制**
   - **非阻塞特性**：fetch/XMLHttpRequest是异步API，调用后立即返回Promise，不阻塞主线程
   - **浏览器进程模型**：网络请求实际在独立的网络进程中执行，与渲染进程并行
   - **事件循环集成**：响应通过事件循环机制回到主线程，与DOM操作无缝集成
   - **内存共享**：主线程可直接访问响应数据，无需序列化传输

2. **Web Worker网络请求机制**
   - **独立JavaScript上下文**：拥有独立的全局对象和事件循环
   - **数据传输开销**：所有数据需要通过结构化克隆算法传输，大数据量时性能损耗明显
   - **DOM隔离**：无法直接操作DOM，需要通过消息传递
   - **并发优势**：可以并行处理多个请求，不影响主线程渲染

**性能对比分析：**

| 维度 | 主线程 | Web Worker |
|------|--------|------------|
| **启动成本** | 低（无需创建新上下文） | 高（需要创建独立JS环境） |
| **数据传输** | 零开销（直接引用） | 高开销（序列化/反序列化） |
| **DOM操作** | 直接访问 | 需要消息传递 |
| **并发处理** | 受事件循环限制 | 真正并行 |
| **错误处理** | 统一异常处理 | 需要跨线程错误传递 |

**应用场景决策树：**

- **选择主线程的场景**：
  - 常规CRUD操作（90%的业务场景）
  - 需要立即更新UI的请求
  - 数据量小于10MB的请求
  - 需要与DOM/BOM API集成的场景

- **选择Web Worker的场景**：
  - 批量数据处理（如CSV解析、图片处理）
  - 长时间运行的计算密集型任务
  - 大量并发请求（如数据同步）
  - 需要保持UI响应性的后台任务

**简化代码示例：**
```javascript
// 主线程：适合常规业务
const data = await fetch('/api/users').then(r => r.json());
updateUI(data);

// Worker：适合批量处理
worker.postMessage({ action: 'processBulkData', urls: [...] });
```

## 一个页面上有大量图片和视频怎么左右滑

**核心理论：**
大量媒体资源的滑动涉及渲染性能、内存管理、网络优化等多个维度的技术挑战。

**技术方案对比分析：**

1. **虚拟滚动 vs 传统滚动**
   - **传统滚动问题**：DOM节点过多导致内存占用高、重排重绘频繁、滚动卡顿
   - **虚拟滚动优势**：恒定的DOM节点数量、O(1)的渲染复杂度、内存使用可控
   - **实现原理**：维护可视窗口概念，动态创建/销毁DOM元素，通过transform模拟滚动

2. **懒加载策略对比**
   
   | 策略 | 原理 | 适用场景 | 性能特点 |
   |------|------|----------|----------|
   | **Intersection Observer** | 基于视口交叉检测 | 现代浏览器，复杂布局 | 性能最优，异步检测 |
   | **Scroll监听** | 监听滚动事件计算位置 | 兼容性要求高 | 同步计算，性能较差 |
   | **距离预测** | 基于滑动速度预测 | 快速滑动场景 | 预测准确性依赖算法 |

3. **预加载策略设计**
   - **时间维度**：基于用户行为模式预测下一个可能访问的内容
   - **空间维度**：当前可视区域前后N屏的内容预加载
   - **优先级策略**：图片优先级高于视频，缩略图优先于原图
   - **网络自适应**：根据网络状况动态调整预加载数量

4. **内存管理策略**
   - **LRU缓存**：最近最少使用的媒体资源优先释放
   - **内存阈值监控**：通过performance.memory监控内存使用
   - **渐进式降级**：内存不足时降低图片质量或停止预加载

**性能优化理论体系：**

1. **渲染层面优化**
   - **GPU加速**：使用transform3d触发硬件加速
   - **合成层优化**：避免不必要的重排重绘
   - **批量DOM操作**：使用DocumentFragment减少回流

2. **网络层面优化**
   - **HTTP/2多路复用**：并行加载多个资源
   - **CDN分发**：就近获取资源
   - **图片格式选择**：WebP/AVIF等现代格式
   - **响应式图片**：根据设备特性加载合适尺寸

3. **用户体验优化**
   - **骨架屏**：加载过程中的视觉占位
   - **渐进式加载**：先显示低质量图片再替换高清版本
   - **平滑动画**：使用requestAnimationFrame确保60fps

**简化实现示例：**
```javascript
// 核心虚拟滚动逻辑
class VirtualMediaSlider {
  render() {
    const visibleRange = this.calculateVisibleRange();
    this.recycleOutOfViewItems(visibleRange);
    this.renderVisibleItems(visibleRange);
  }
  
  // Intersection Observer懒加载
  setupLazyLoading() {
    this.observer = new IntersectionObserver(
      entries => entries.forEach(this.loadMedia),
      { rootMargin: '50px' } // 提前50px开始加载
    );
  }
}
```

## 图片或视频请求失败怎么做重试

**重试机制理论基础：**
重试机制设计需要平衡用户体验、服务器压力和网络资源消耗，涉及数学建模、概率论和分布式系统理论。

**核心重试策略对比：**

1. **退避算法对比**
   
   | 策略 | 公式 | 优点 | 缺点 | 适用场景 |
   |------|------|------|------|----------|
   | **固定间隔** | delay = constant | 简单，可预测 | 可能加剧服务器压力 | 轻量级场景 |
   | **线性退避** | delay = baseDelay × retryCount | 逐步减少压力 | 增长过慢 | 短期故障 |
   | **指数退避** | delay = baseDelay × 2^retryCount | 快速减少并发 | 可能等待过长 | 服务器过载 |
   | **指数退避+抖动** | delay + random(0, jitter) | 避免惊群效应 | 实现复杂 | 高并发场景 |

2. **错误分类与重试策略**
   - **可重试错误**：网络超时(408)、服务器过载(503)、临时不可用(502/504)
   - **不可重试错误**：认证失败(401)、资源不存在(404)、权限不足(403)
   - **条件重试错误**：限流(429)需要更长等待，客户端错误(4xx)需要修正请求

3. **重试成功率数学模型**
   ```
   总成功率 = 1 - (失败率)^(重试次数+1)
   
   例如：单次成功率90%，重试3次
   总成功率 = 1 - 0.1^4 = 99.99%
   ```

4. **断路器模式集成**
   - **熔断状态**：连续失败达到阈值时停止重试
   - **半开状态**：定期尝试恢复，避免永久熔断
   - **恢复机制**：基于成功率动态调整重试策略

**高级重试策略设计：**

1. **自适应重试**
   - **网络状况感知**：基于RTT和丢包率调整重试参数
   - **成功率统计**：动态调整最大重试次数
   - **时间窗口分析**：区分不同时间段的重试策略

2. **资源优雅降级体系**
   - **多CDN切换**：主CDN失败后自动切换备用CDN
   - **格式降级**：WebP失败后尝试JPEG，高清失败后尝试缩略图
   - **占位符策略**：最终失败时显示有意义的占位内容

3. **批量重试优化**
   - **去重机制**：相同资源避免重复重试
   - **优先级队列**：关键资源优先重试
   - **并发控制**：限制同时重试的资源数量

**监控与可观测性：**
- **重试成功率**：监控不同错误类型的重试效果
- **延迟分布**：分析重试对用户体验的影响
- **资源消耗**：评估重试机制的成本效益

**简化实现示例：**
```javascript
class SmartRetryManager {
  async loadWithRetry(url, options = {}) {
    const strategy = this.selectStrategy(url, options);
    return this.executeWithBackoff(url, strategy);
  }
  
  selectStrategy(url, options) {
    // 基于历史数据和当前网络状况选择最优策略
    return {
      maxRetries: this.calculateOptimalRetries(url),
      backoffType: 'exponential-jitter',
      fallbackChain: this.buildFallbackChain(url)
    };
  }
}
```

## 性能优化案例（首屏加载、资源压缩、CDN策略等）

**性能优化理论体系：**
现代Web性能优化基于RAIL模型（Response、Animation、Idle、Load）和Core Web Vitals指标，需要从网络层、渲染层、应用层三个维度系统性优化。

**关键性能指标与优化目标：**

1. **Core Web Vitals标准**
   - **LCP (Largest Contentful Paint)**：最大内容绘制 < 2.5s
   - **FID (First Input Delay)**：首次输入延迟 < 100ms  
   - **CLS (Cumulative Layout Shift)**：累积布局偏移 < 0.1
   - **FCP (First Contentful Paint)**：首次内容绘制 < 1.8s
   - **TTI (Time to Interactive)**：可交互时间 < 5s

2. **性能优化策略矩阵**

   | 优化维度 | 技术方案 | 理论基础 | 性能提升 | 实施复杂度 |
   |----------|----------|----------|----------|------------|
   | **网络优化** | HTTP/2, CDN, 压缩 | 减少网络延迟和带宽消耗 | 30-50% | 低-中 |
   | **资源优化** | 代码分割, Tree-shaking | 减少关键路径资源大小 | 20-40% | 中 |
   | **缓存策略** | 强缓存, 协商缓存, SW | 避免重复网络请求 | 50-80% | 中-高 |
   | **渲染优化** | SSR, 预渲染, 流式渲染 | 提前生成可视内容 | 40-60% | 高 |

**深度技术方案对比：**

1. **首屏渲染策略对比**
   
   - **客户端渲染(CSR)**
     - 优势：开发简单，用户交互流畅
     - 劣势：首屏白屏时间长，SEO不友好
     - 适用：后台管理系统，交互密集应用
   
   - **服务端渲染(SSR)**  
     - 优势：首屏快速显示，SEO友好
     - 劣势：服务器压力大，TTFB可能较高
     - 适用：内容型网站，电商首页
   
   - **静态生成(SSG)**
     - 优势：性能最佳，CDN友好
     - 劣势：动态内容支持有限
     - 适用：文档站点，营销页面
   
   - **增量静态再生(ISR)**
     - 优势：结合SSG和SSR优势
     - 劣势：实现复杂，缓存策略复杂
     - 适用：大型内容站点

2. **资源加载优化策略**
   
   - **预加载策略对比**
     ```html
     <!-- DNS预解析：减少DNS查询时间 -->
     <link rel="dns-prefetch" href="//cdn.example.com">
     
     <!-- 预连接：建立完整连接 -->
     <link rel="preconnect" href="//fonts.googleapis.com">
     
     <!-- 资源预加载：提前下载关键资源 -->
     <link rel="preload" href="critical.css" as="style">
     
     <!-- 预取：空闲时下载可能需要的资源 -->
     <link rel="prefetch" href="next-page.js">
     ```
   
   - **代码分割策略**
     - **路由级分割**：按页面拆分，适合SPA应用
     - **组件级分割**：按功能模块拆分，精细控制
     - **供应商分割**：分离第三方库，利用缓存
     - **动态导入**：运行时按需加载

3. **缓存策略设计理论**
   
   - **多级缓存架构**
     ```
     浏览器缓存 → CDN缓存 → 反向代理缓存 → 应用缓存 → 数据库缓存
     ```
   
   - **缓存策略选择矩阵**
     
     | 资源类型 | 更新频率 | 推荐策略 | 缓存时长 |
     |----------|----------|----------|----------|
     | **HTML** | 高 | 协商缓存 | no-cache |
     | **CSS/JS** | 中 | 强缓存+版本号 | 1年 |
     | **图片** | 低 | 强缓存 | 30天 |
     | **API数据** | 高 | 协商缓存+SW | 5分钟 |

4. **CDN选择与优化策略**
   
   - **CDN架构对比**
     - **推送型CDN**：适合大文件，更新频率低
     - **拉取型CDN**：适合小文件，更新频率高
     - **边缘计算CDN**：支持动态内容，计算下沉
   
   - **多CDN策略**
     - **主备切换**：主CDN故障时自动切换
     - **智能调度**：基于用户地理位置和网络状况选择
     - **成本优化**：根据流量和成本选择最优CDN

**性能监控与持续优化：**
- **RUM监控**：真实用户体验数据收集
- **合成监控**：定期性能基准测试  
- **性能预算**：设定性能指标阈值，持续监控
- **A/B测试**：对比不同优化方案的效果

## 在网页中怎么发一个接口请求

**HTTP请求技术架构理论：**
Web API请求涉及浏览器网络栈、JavaScript引擎、安全策略等多层架构，不同API有着不同的设计哲学和适用场景。

**请求方式底层原理对比：**

1. **技术架构层次分析**
   ```
   应用层API (fetch/xhr/axios) 
   ↓
   浏览器网络API层
   ↓  
   HTTP协议栈 (HTTP/1.1, HTTP/2, HTTP/3)
   ↓
   TCP/UDP传输层
   ↓
   网络物理层
   ```

2. **核心API技术特性对比**

   | 特性维度 | Fetch API | XMLHttpRequest | Axios | 现代替代方案 |
   |----------|-----------|----------------|-------|--------------|
   | **设计哲学** | 现代Promise流式 | 事件驱动回调 | 封装便利性 | 类型安全 |
   | **流式处理** | ✅ ReadableStream | ❌ 全量加载 | ❌ 基于XHR | ✅ 原生支持 |
   | **请求取消** | ✅ AbortController | ✅ abort() | ✅ CancelToken | ✅ 标准化 |
   | **上传进度** | ❌ 需要自实现 | ✅ progress事件 | ✅ onUploadProgress | 🔄 开发中 |
   | **错误处理** | 手动检查status | 状态码事件 | 自动化处理 | 类型化错误 |
   | **缓存控制** | ✅ 精细控制 | ✅ 基础支持 | ✅ 封装支持 | ✅ 增强控制 |

3. **性能与兼容性权衡**
   
   - **Fetch API优势**
     - **内存效率**：流式处理大文件，避免内存溢出
     - **现代异步**：原生Promise支持，避免回调地狱
     - **标准化**：W3C标准，未来发展方向
     - **Service Worker集成**：完美支持离线缓存
   
   - **XMLHttpRequest优势**
     - **兼容性**：IE5+全面支持
     - **进度监控**：上传下载进度精确控制
     - **同步请求**：虽不推荐但仍支持
     - **二进制处理**：responseType多样化支持

4. **高级请求模式设计**

   - **请求拦截器模式**
     ```javascript
     // 统一请求预处理
     const apiClient = {
       request: (config) => {
         // 身份验证、日志记录、错误重试
         return fetch(config.url, this.processConfig(config));
       }
     };
     ```
   
   - **并发控制模式**
     - **请求队列**：限制同时发起的请求数量
     - **请求去重**：相同请求合并处理
     - **批量请求**：多个API合并为单次请求
   
   - **缓存策略集成**
     - **HTTP缓存**：利用浏览器缓存机制
     - **应用缓存**：内存中缓存响应数据
     - **持久化缓存**：LocalStorage/IndexedDB存储

5. **错误处理与容错设计**
   
   - **错误分类体系**
     - **网络错误**：连接超时、DNS解析失败
     - **HTTP错误**：4xx客户端错误、5xx服务器错误  
     - **业务错误**：接口返回的业务逻辑错误
     - **解析错误**：响应数据格式错误
   
   - **容错策略选择**
     - **快速失败**：立即抛出错误，适合关键业务
     - **优雅降级**：提供备用数据或功能
     - **重试机制**：自动重试临时性错误
     - **断路器模式**：防止级联故障

**现代化请求最佳实践：**
```javascript
// 现代化API客户端设计
class ModernApiClient {
  constructor(config) {
    this.baseURL = config.baseURL;
    this.interceptors = { request: [], response: [] };
    this.abortController = new AbortController();
  }
  
  async request(config) {
    const processedConfig = await this.processRequest(config);
    const response = await fetch(processedConfig.url, {
      ...processedConfig,
      signal: this.abortController.signal
    });
    
    return this.processResponse(response);
  }
}
```

**技术选型决策树：**
- **选择Fetch**：现代应用、需要流式处理、Service Worker集成
- **选择XMLHttpRequest**：需要上传进度、兼容老版本浏览器  
- **选择Axios**：快速开发、需要丰富的封装功能
- **自建封装**：特殊业务需求、性能极致优化

## url到页面构建的过程中，中间的白屏和首屏加载如何优化

**页面加载完整理论模型：**
从URL输入到页面完全可交互，涉及网络层、解析层、渲染层、JavaScript执行层的复杂交互过程。

**页面加载生命周期深度分析：**

1. **网络请求阶段 (0-200ms目标)**
   ```
   URL解析 → DNS查询 → TCP连接 → TLS握手 → HTTP请求 → 服务器处理 → 响应返回
   ```
   
   **优化策略**：
   - **DNS优化**：DNS预解析、DNS-over-HTTPS、智能DNS
   - **连接优化**：HTTP/2多路复用、连接预热、Keep-Alive
   - **协议优化**：HTTP/3 QUIC、Early Hints、Server Push

2. **资源解析阶段 (200-500ms目标)**
   ```
   HTML解析 → DOM构建 → CSS解析 → CSSOM构建 → 渲染树构建
   ```
   
   **关键路径优化**：
   - **HTML流式解析**：避免阻塞性脚本，优化文档结构
   - **CSS优化**：关键CSS内联、非关键CSS延迟加载
   - **JavaScript优化**：defer/async属性、模块化加载

3. **渲染绘制阶段 (500-1000ms目标)**
   ```
   布局计算 → 图层分离 → 绘制指令 → 合成显示
   ```
   
   **渲染性能优化**：
   - **布局优化**：避免强制同步布局、批量DOM操作
   - **绘制优化**：减少重绘区域、使用transform替代位置变化
   - **合成优化**：合理使用硬件加速、避免层爆炸

**白屏问题根因分析与解决方案：**

1. **白屏原因分类**
   
   | 白屏类型 | 根本原因 | 持续时间 | 解决策略 |
   |----------|----------|----------|----------|
   | **网络白屏** | DNS/连接/传输慢 | 2-10s | 网络层优化 |
   | **解析白屏** | HTML/CSS阻塞 | 0.5-2s | 关键路径优化 |
   | **渲染白屏** | JavaScript执行阻塞 | 0.2-1s | 异步加载优化 |
   | **交互白屏** | 框架初始化慢 | 1-3s | 代码分割优化 |

2. **渐进式渲染策略**
   
   - **骨架屏设计原理**
     ```
     结构占位 → 内容填充 → 交互激活
     ```
     - **静态骨架屏**：预设计的占位结构
     - **动态骨架屏**：基于组件结构自动生成
     - **智能骨架屏**：基于用户历史数据预测
   
   - **流式渲染技术**
     - **服务端流式渲染**：边计算边传输HTML
     - **客户端流式更新**：增量DOM更新
     - **组件级流式加载**：按优先级逐步渲染

3. **关键资源优先级管理**
   
   - **资源优先级矩阵**
     
     | 资源类型 | 阻塞渲染 | 优先级 | 加载策略 |
     |----------|----------|--------|----------|
     | **关键CSS** | ✅ | 最高 | 内联/预加载 |
     | **首屏图片** | ❌ | 高 | 预加载 |
     | **JavaScript** | ✅ | 中 | defer/async |
     | **字体文件** | ❌ | 中 | 预加载+fallback |
     | **非首屏资源** | ❌ | 低 | 懒加载 |
   
   - **智能预加载算法**
     - **用户行为预测**：基于鼠标移动、滚动行为预测
     - **路由预加载**：根据导航模式预加载可能访问的页面
     - **时间片预加载**：利用浏览器空闲时间预加载资源

**现代化首屏优化技术栈：**

1. **构建时优化**
   - **关键路径分析**：识别首屏必需资源
   - **代码分割策略**：按路由、按功能、按重要性分割
   - **Tree Shaking**：消除未使用代码
   - **Bundle分析**：优化包体积和依赖关系

2. **运行时优化**
   - **Service Worker缓存**：离线优先策略
   - **CDN边缘计算**：就近内容生成和缓存
   - **HTTP/2 Push**：主动推送关键资源
   - **预渲染技术**：构建时生成静态HTML

3. **用户体验优化**
   - **感知性能**：loading状态、进度指示器
   - **交互反馈**：即时响应、乐观更新
   - **错误处理**：优雅降级、重试机制

**性能预算与监控体系：**
- **Core Web Vitals目标**：LCP < 2.5s, FID < 100ms, CLS < 0.1
- **自定义指标**：首屏时间、可交互时间、关键用户路径时间
- **A/B测试**：对比不同优化策略的效果
- **RUM监控**：真实用户环境下的性能数据收集

## monorepo相较于multirepo的好处，monorepo各种解决方案的区别，为啥不用npm workspace

**Monorepo vs Multirepo 架构理论：**
代码仓库架构选择涉及团队协作、技术债务、构建效率、发布策略等多个维度的权衡，需要基于组织结构和技术栈特点进行决策。

**架构模式深度对比：**

1. **组织架构影响分析**
   
   | 维度 | Monorepo | Multirepo | 混合模式 |
   |------|----------|-----------|----------|
   | **团队协作** | 统一协作，原子性变更 | 独立开发，清晰边界 | 按业务域分离 |
   | **代码共享** | 零成本共享，实时同步 | 需要版本管理，延迟更新 | 核心库统一，业务分离 |
   | **技术栈统一** | 强制统一，工具链一致 | 技术栈自由，工具多样 | 基础设施统一 |
   | **发布策略** | 统一发布或独立发布 | 完全独立发布 | 分层发布策略 |
   | **权限管理** | 细粒度权限控制 | 仓库级权限隔离 | 混合权限模型 |

2. **技术债务与维护成本**
   
   - **Monorepo优势**
     - **重构友好**：跨项目重构可以原子性完成
     - **依赖升级**：统一依赖版本，减少兼容性问题
     - **代码质量**：统一代码规范和质量门禁
     - **知识共享**：团队成员可以跨项目学习和贡献
   
   - **Multirepo优势**
     - **技术多样性**：不同项目可以选择最适合的技术栈
     - **团队自治**：每个团队可以独立决策和发布
     - **故障隔离**：单个仓库问题不影响其他项目
     - **权限简单**：基于仓库的权限模型更直观

**主流Monorepo工具深度对比：**

1. **技术架构对比分析**

   | 工具 | 核心架构 | 缓存策略 | 构建引擎 | 适用规模 | 学习成本 |
   |------|----------|----------|----------|----------|----------|
   | **Lerna** | 包管理+发布 | 无内置缓存 | 外部工具 | 中小型 | 低 |
   | **Nx** | 任务图+缓存 | 分布式缓存 | 自研引擎 | 大型 | 中高 |
   | **Rush** | 企业级管理 | 云缓存 | 可插拔 | 超大型 | 高 |
   | **Turborepo** | 增量构建 | 远程缓存 | 并行引擎 | 中大型 | 中 |
   | **Bazel** | 构建系统 | 内容寻址 | 原生构建 | 超大型 | 极高 |

2. **性能优化机制深度解析**
   
   - **增量构建理论**
     ```
     文件变更检测 → 依赖图分析 → 影响范围计算 → 最小构建集合
     ```
     - **内容哈希**：基于文件内容而非时间戳判断变更
     - **依赖图优化**：精确计算受影响的包和任务
     - **并行执行**：基于依赖关系的最大并行度执行
   
   - **缓存策略对比**
     - **本地缓存**：基于文件系统的快速缓存
     - **远程缓存**：团队共享的分布式缓存
     - **云缓存**：基于云服务的全局缓存
     - **内容寻址**：基于输入内容哈希的缓存键

3. **npm workspaces局限性深度分析**
   
   **功能对比矩阵**：
   
   | 功能领域 | npm workspaces | 专业工具 | 差距分析 |
   |----------|----------------|----------|----------|
   | **依赖管理** | ✅ 基础hoisting | ✅ 智能依赖解析 | 缺乏冲突检测 |
   | **构建优化** | ❌ 无增量构建 | ✅ 智能缓存+并行 | 性能差距巨大 |
   | **任务编排** | ❌ 简单脚本 | ✅ 依赖图执行 | 无法处理复杂依赖 |
   | **发布管理** | ❌ 手动管理 | ✅ 自动化发布 | 缺乏版本策略 |
   | **开发体验** | ❌ 基础支持 | ✅ 丰富工具链 | IDE集成不足 |
   | **可观测性** | ❌ 无监控 | ✅ 构建分析 | 缺乏性能洞察 |

**企业级Monorepo最佳实践：**

1. **代码组织策略**
   ```
   packages/
   ├── apps/          # 应用程序
   ├── libs/          # 共享库
   ├── tools/         # 构建工具
   └── configs/       # 配置文件
   ```

2. **依赖管理策略**
   - **版本统一策略**：关键依赖版本统一，避免重复打包
   - **依赖边界控制**：防止循环依赖，明确依赖方向
   - **外部依赖管理**：统一管理第三方依赖版本

3. **构建与发布策略**
   - **增量构建**：只构建变更影响的包
   - **并行构建**：最大化利用构建资源
   - **语义化版本**：自动化版本管理和变更日志生成
   - **分阶段发布**：金丝雀发布和灰度发布

**选型决策框架：**
- **选择npm workspaces**：简单项目、学习成本敏感、基础需求
- **选择Lerna**：传统Node.js项目、发布管理重要
- **选择Nx**：现代前端项目、性能要求高、工具链丰富
- **选择Turborepo**：构建性能优先、配置简单
- **选择Rush**：大型企业、复杂依赖关系、严格治理需求

## 给定一个状态为 fulfilled 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise P3 时，新的 Promise P2 的状态和值分别是什么？

**Promise状态转换理论机制：**
Promise的then方法基于Promise/A+规范实现，涉及微任务调度、状态转换和值传递的复杂机制。

**Promise状态转换核心原理：**

1. **状态转换规则体系**
   ```
   fulfilled Promise → then回调 → 新Promise状态由回调结果决定
   
   回调结果类型决策树：
   ├── 正常值 → fulfilled
   ├── 抛出异常 → rejected  
   ├── 返回Promise → 状态跟随
   └── 返回thenable → 解析后跟随
   ```

2. **微任务调度机制**
   - **同步执行**：then方法本身同步返回新Promise
   - **异步回调**：回调函数在下一个微任务中执行
   - **状态传播**：通过微任务队列实现异步状态传播
   - **链式调用**：每个then都创建新Promise，形成Promise链

3. **值传递与Promise解析算法**
   
   | 回调返回值类型 | 解析规则 | 新Promise状态 | 新Promise值 |
   |----------------|----------|---------------|-------------|
   | **普通值** | 直接传递 | fulfilled | 返回值本身 |
   | **undefined** | 默认返回 | fulfilled | undefined |
   | **null** | 直接传递 | fulfilled | null |
   | **抛出异常** | 异常捕获 | rejected | 异常对象 |
   | **Promise对象** | Promise解析 | 跟随Promise | 跟随Promise |
   | **thenable对象** | thenable解析 | 取决于then | 取决于then |

4. **Promise解析算法详解**
   - **Promise跟随机制**：返回Promise时，新Promise会"跟随"返回的Promise
   - **递归解析**：如果返回的Promise又resolve一个Promise，会递归解析
   - **循环检测**：防止Promise解析自身导致的无限循环
   - **异常处理**：解析过程中的任何异常都会导致rejection

**高级Promise模式分析：**

1. **Promise穿透现象**
   ```javascript
   Promise.resolve('value')
     .then() // 没有回调函数
     .then(value => console.log(value)); // 输出: 'value'
   ```
   - **穿透原理**：then(null)会被替换为默认的值传递函数
   - **实现机制**：`value => value` 和 `reason => { throw reason }`

2. **错误传播链**
   ```javascript
   Promise.reject('error')
     .then(value => 'success') // 不执行
     .then(value => 'success2') // 不执行  
     .catch(error => 'handled'); // 执行，返回fulfilled
   ```
   - **错误冒泡**：rejection会沿着Promise链向下传播
   - **错误恢复**：catch处理后返回fulfilled状态

**简化示例分析：**
```javascript
// 核心场景演示
const P1 = Promise.resolve('initial');

// 1. 正常值 → fulfilled('new value')
P1.then(v => 'new value');

// 2. 异常 → rejected(Error)
P1.then(v => { throw new Error('error'); });

// 3. null → fulfilled(null) 
P1.then(v => null);

// 4. Promise → 状态跟随
P1.then(v => Promise.resolve('P3 value'));
```

## 给定一个状态为 rejected 的 Promise P1，当 .then() 的回调函数分别正常返回、抛出错误、返回 null、返回一个新的 Promise 时，新的 Promise P2 的状态和值/原因分别是什么？

**Rejected Promise处理机制理论：**
Rejected Promise的处理涉及错误传播、异常恢复和回调选择的复杂逻辑，是Promise错误处理体系的核心。

**错误处理决策树：**
```
Rejected Promise → then(onFulfilled, onRejected)
├── 只有onFulfilled → 错误穿透 (rejected)
├── 有onRejected → 执行onRejected
│   ├── 正常返回 → fulfilled(返回值)
│   ├── 抛出异常 → rejected(新异常)
│   └── 返回Promise → 状态跟随
└── 无回调 → 错误穿透 (rejected)
```

**错误恢复与传播机制：**

1. **错误穿透原理**
   - **机制**：onRejected为空时，等价于 `reason => { throw reason }`
   - **目的**：确保错误能沿着Promise链传播到能处理它的地方
   - **实现**：内部自动插入默认的错误传递函数

2. **错误恢复模式**
   - **值恢复**：onRejected返回正常值，Promise链恢复为fulfilled
   - **Promise恢复**：onRejected返回fulfilled Promise，实现异步恢复
   - **条件恢复**：基于错误类型选择性恢复或继续传播

3. **错误转换策略**
   - **错误包装**：将原始错误包装为更具体的错误类型
   - **错误映射**：根据错误代码映射为用户友好的错误信息
   - **错误聚合**：多个错误合并为单一错误对象

**核心场景分析：**
```javascript
const P1 = Promise.reject('initial error');

// 1. 错误穿透 → rejected('initial error')
P1.then(v => 'success');

// 2. 错误恢复 → fulfilled('handled')
P1.then(null, e => 'handled');

// 3. 错误转换 → rejected(new Error)
P1.then(null, e => { throw new Error('new'); });

// 4. 异步恢复 → 跟随返回的Promise
P1.then(null, e => Promise.resolve('recovered'));
```

## 如果用户操作总是有弹窗显示失败，咋排查问题?如果是线上环境呢?

**线上问题排查方法论体系：**
线上问题排查需要建立系统化的可观测性体系，结合多维度数据分析和科学的故障定位方法。

**问题排查理论框架：**

1. **故障分类与优先级矩阵**
   
   | 影响范围 | 用户体验影响 | 业务影响 | 排查优先级 | 处理策略 |
   |----------|-------------|----------|-----------|----------|
   | **全局故障** | 严重 | 高 | P0 | 立即响应，全员参与 |
   | **功能故障** | 中等 | 中 | P1 | 快速定位，专项修复 |
   | **个别用户** | 轻微 | 低 | P2 | 数据分析，批量处理 |
   | **边缘场景** | 可忽略 | 极低 | P3 | 长期优化，版本规划 |

2. **多维度排查体系**
   
   - **时间维度分析**
     - **故障时间线**：问题首次出现、影响扩散、修复时间
     - **周期性分析**：是否存在时间规律性（高峰期、特定时段）
     - **版本关联**：与代码发布、配置变更的时间关联
   
   - **用户维度分析**
     - **用户画像**：受影响用户的地域、设备、浏览器分布
     - **行为路径**：用户操作序列、页面访问轨迹
     - **环境特征**：网络状况、设备性能、系统版本
   
   - **系统维度分析**
     - **服务拓扑**：微服务调用链路、依赖关系
     - **资源使用**：CPU、内存、网络、存储指标
     - **外部依赖**：第三方服务、CDN、数据库状态

3. **线上问题排查工具链**

   **前端监控体系**：
   - **错误监控**：Sentry、Bugsnag等实时错误收集
   - **性能监控**：Web Vitals、用户行为漏斗分析
   - **用户会话**：FullStory、LogRocket等会话录制
   - **实时日志**：前端日志实时上报和分析

   **后端监控体系**：
   - **APM监控**：应用性能监控，调用链追踪
   - **基础监控**：系统资源、网络、存储监控
   - **业务监控**：关键业务指标、SLA监控
   - **日志聚合**：ELK、Fluentd等日志收集分析

4. **科学排查方法论**

   - **假设驱动排查**
     ```
     观察现象 → 提出假设 → 设计验证 → 收集证据 → 验证或推翻假设
     ```
   
   - **分层隔离定位**
     ```
     用户层 → 前端层 → 网关层 → 服务层 → 数据层 → 基础设施层
     ```
   
   - **对比分析法**
     - **时间对比**：故障前后的系统状态对比
     - **版本对比**：不同版本间的行为差异
     - **环境对比**：线上与测试环境的配置差异
     - **用户对比**：正常用户与异常用户的特征对比

**高级排查技术与工具：**

1. **分布式追踪技术**
   - **链路追踪**：Jaeger、Zipkin等分布式追踪系统
   - **调用图分析**：服务调用关系和性能瓶颈识别
   - **异常传播**：错误在微服务间的传播路径

2. **智能化问题诊断**
   - **异常检测**：基于机器学习的异常模式识别
   - **根因分析**：自动化根本原因分析引擎
   - **故障预测**：基于历史数据的故障预警

3. **A/B测试与灰度分析**
   - **功能开关**：快速回滚有问题的功能
   - **流量分割**：部分用户验证修复效果
   - **指标对比**：修复前后的关键指标对比

**线上问题处理最佳实践：**

1. **应急响应流程**
   - **快速止血**：立即降低影响范围
   - **问题隔离**：防止问题扩散
   - **临时方案**：快速恢复核心功能
   - **根本修复**：深度分析并彻底解决

2. **故障复盘机制**
   - **时间线梳理**：详细记录故障处理过程
   - **根因分析**：深入挖掘问题根本原因
   - **改进措施**：制定防范类似问题的措施
   - **知识沉淀**：建立故障知识库

**实战排查示例：**
```javascript
// 前端错误监控集成
window.addEventListener('error', (event) => {
  const errorInfo = {
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    stack: event.error?.stack,
    userAgent: navigator.userAgent,
    url: location.href,
    timestamp: Date.now()
  };
  
  // 上报到监控系统
  sendErrorToMonitoring(errorInfo);
});
```

## 一个微任务递归地生成另一个微任务，会陷入死循环吗？

**事件循环与微任务调度理论：**
微任务递归涉及JavaScript事件循环机制、浏览器任务调度策略和性能保护机制的深层交互。

**事件循环核心机制深度解析：**

1. **任务队列优先级体系**
   ```
   调用栈 (Call Stack)
   ↓ (栈空时)
   微任务队列 (Microtask Queue) - 最高优先级
   ↓ (微任务队列空时)  
   宏任务队列 (Macrotask Queue) - 较低优先级
   ↓
   渲染任务 (Render Tasks) - 特殊优先级
   ```

2. **微任务处理算法**
   ```
   while (微任务队列不为空) {
     执行下一个微任务;
     if (执行时间超过阈值) {
       浏览器保护机制介入;
       break;
     }
   }
   ```

3. **递归微任务的执行模式**
   - **理论无限性**：每个微任务都可以产生新的微任务
   - **实际有限性**：浏览器实现了多种保护机制
   - **优先级维持**：递归微任务仍然优于宏任务执行

**浏览器保护机制详解：**

1. **时间片保护 (Time Slicing)**
   - **Chrome实现**：单次微任务循环最大执行时间约4-5ms
   - **Firefox实现**：基于任务数量限制，通常1000个左右
   - **Safari实现**：结合时间和任务数量的混合策略

2. **内存保护机制**
   - **调用栈限制**：递归深度达到限制时抛出RangeError
   - **内存监控**：微任务队列大小监控和限制
   - **垃圾回收**：强制GC介入清理内存

3. **用户体验保护**
   - **渲染优先级**：关键渲染任务可以中断微任务执行
   - **用户交互**：高优先级用户事件可以打断微任务循环
   - **页面响应性**：长时间阻塞会触发"页面无响应"警告

**不同JavaScript引擎的实现差异：**

| 引擎 | 保护策略 | 阈值设置 | 中断机制 | 错误处理 |
|------|----------|----------|----------|----------|
| **V8 (Chrome)** | 时间片+计数 | ~5ms/1000个 | 可中断 | 警告+限制 |
| **SpiderMonkey (Firefox)** | 计数为主 | ~1000个 | 强制中断 | 抛出异常 |
| **JavaScriptCore (Safari)** | 混合策略 | 动态调整 | 渐进中断 | 软限制 |
| **Chakra (Edge)** | 时间片 | ~4ms | 可中断 | 警告机制 |

**微任务饥饿问题分析：**

1. **宏任务饥饿现象**
   - **根本原因**：微任务优先级绝对高于宏任务
   - **影响范围**：setTimeout、setInterval、I/O事件、UI事件
   - **表现形式**：定时器延迟、界面卡顿、交互无响应

2. **渲染阻塞机制**
   - **60FPS目标**：每帧16.67ms的渲染时间窗口
   - **微任务影响**：长时间微任务执行会跳帧
   - **浏览器策略**：关键渲染路径优先级提升

3. **性能影响评估**
   ```javascript
   // 性能测试示例
   const startTime = performance.now();
   let count = 0;
   
   function recursiveMicrotask() {
     count++;
     if (performance.now() - startTime < 1000) {
       Promise.resolve().then(recursiveMicrotask);
     } else {
       console.log(`1秒内执行了${count}个微任务`);
     }
   }
   ```

**实际应用中的最佳实践：**

1. **避免微任务递归的设计模式**
   - **批处理模式**：将多个微任务合并为单个处理
   - **时间分片**：主动使用setTimeout分割长任务
   - **队列控制**：限制微任务队列的最大长度

2. **安全的异步递归模式**
   ```javascript
   // 推荐：使用宏任务分片
   function safeRecursiveTask(data, callback) {
     const batchSize = 100;
     const batch = data.splice(0, batchSize);
     
     // 处理当前批次
     batch.forEach(callback);
     
     // 如果还有数据，使用宏任务继续
     if (data.length > 0) {
       setTimeout(() => safeRecursiveTask(data, callback), 0);
     }
   }
   ```

**理论总结：**
- **不会传统死循环**：浏览器有多重保护机制
- **会造成性能问题**：阻塞宏任务和渲染
- **引擎实现不同**：不同浏览器的处理策略有差异
- **需要主动避免**：设计时应该考虑任务调度的平衡性
