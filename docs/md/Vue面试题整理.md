# Vue 面试题整理

## 一、Vue2 与 Vue3 的区别

### 1. 性能优化

- **虚拟 DOM 重构**：Vue3的虚拟DOM采用了更高效的 Diff算法，减少了渲染和更新的开销
- **Tree-shaking 支持**：按需编译代码，减小打包体积（如未用到的功能不打包）

### 2. Composition API

- **Vue2**：基于选项式 API（data、methods 分块），逻辑分散
- **Vue3**：新增 setup 函数，允许用组合式 API 按功能组织代码，逻辑复用更灵活（替代 Mixins），提升代码可维护性

### 3. 响应式系统改进

- **Vue2**：使用 Object.defineProperty 实现响应式，无法监听新增属性和数组索引变化
- **Vue3**：使用 Proxy 实现响应式，解决了 Vue2 的局限性

### 4. 新特性和改进

- **Teleport**：可以将组件的DOM渲染到指定的DOM节点之外，例如模态框、通知等
- **Fragment 支持**：Vue3支持组件返回多个根节点，不再限制单一根节点（允许多个template）
- **TypeScript 支持**：Vue3原生支持 TypeScript，提供更完善的类型推导和开发体验
- **多 v-model 支持**：Vue3支持为一个组件绑定多个 v-model，并且可以自定义 prop 和 event 名称

## 二、Vue 组件通信方式

### 1. 父子组件通信

- **Props**：父组件通过 props 向子组件传递数据
- **$emit**：子组件通过 $emit 向父组件发送事件，并可以传递数据
- **获取组件实例对象**：
  - Vue 2：通过 `this.$parent` 获取父组件实例，或通过 `this.$children` 获取子组件实例
  - Vue 3：通过 ref 引用子组件，直接访问其属性和方法
- **多 v-model 绑定**：Vue 3 组件支持多个 v-model 绑定和自定义属性名，父子之间的双向绑定更加灵活

### 2. 跨组件通信

- **Provide / Inject**：父组件通过 provide 向后代组件传递数据，后代组件使用 inject 接收数据，适用于深层嵌套组件间的通信
- **Vuex**：通过全局状态管理库 Vuex 共享状态，实现跨组件通信（Vue2）
- **Pinia**：Pinia 是 Vue 3 推荐的全局状态管理库，替代了 Vuex
- **事件总线**：Vue 2 中可以通过Event Bus实现组件间的通信，但在 Vue 3 中不推荐使用
- **全局事件处理器**：通过在根组件$root或全局对象上监听事件，进行跨组件通信（Vue 3 推荐使用外部库，如 mitt）

## 三、Vue 组件生命周期

### Vue2 生命周期

#### 创建阶段

1. **beforeCreate**：组件实例刚被创建，数据观测和事件/监听器设置之前。此时无法访问 data、computed 和 methods 等
2. **created**：组件实例已创建，数据观测、事件/监听器设置完成，此时可以访问 data、computed 和 methods 等，通常用于数据初始化

#### 挂载阶段

1. **beforeMount**：在挂载开始之前，模板已编译，el 和 template 已经确定，但尚未渲染
2. **mounted**：组件实例挂载到 DOM 上之后，此时可以访问和操作 DOM

#### 更新阶段

1. **beforeUpdate**：数据发生变化，DOM 尚未更新。可以在这里做一些数据处理，避免不必要的渲染
2. **updated**：数据变化，DOM 更新后调用。此时组件的 DOM 已经更新，可以访问和操作新的 DOM

#### 销毁阶段

1. **beforeDestroy**：组件实例销毁之前。可以在此阶段进行清理工作，例如移除事件监听器、定时器等
2. **destroyed**：组件实例销毁之后。此时，所有的事件监听器和子组件已被销毁

### Vue3 生命周期

#### 创建阶段

1. **onBeforeMount**：等效于 Vue 2 中的 beforeMount，在组件挂载之前调用
2. **onMounted**：等效于 Vue 2 中的 mounted，在组件挂载之后调用

#### 更新阶段

1. **onBeforeUpdate**：等效于 Vue 2 中的 beforeUpdate，在数据更新之前调用
2. **onUpdated**：等效于 Vue 2 中的 updated，在数据更新并渲染之后调用

#### 销毁阶段

1. **onBeforeUnmount**：等效于 Vue 2 中的 beforeDestroy，在组件卸载前调用
2. **onUnmounted**：等效于 Vue 2 中的 destroyed，在组件卸载后调用

### Vue 组件在哪个生命周期发送 Ajax 请求

#### created 钩子

**优点**：

- ✅ 更快获取数据：能尽早获取服务端数据，减少页面加载时间
- ✅ SSR 支持：支持服务器端渲染（SSR），在 SSR 环境中不会受到限制

**缺点**：

- ❌ UI 未渲染时发起请求：如果需要操作 DOM 或渲染数据，可能导致闪屏问题

#### mounted 钩子

**优点**：

- ✅ DOM 可用：适合需要操作 DOM 或渲染数据后再发起请求的情况，避免闪屏

**缺点**：

- ❌ 请求延迟：数据请求会稍微延迟，增加页面加载时间
- ❌ SSR 不支持：mounted 只在客户端执行，不适用于 SSR 环境

### Vue 父子组件生命周期调用顺序

#### 1. 创建阶段

- 父组件：beforeCreate → created
- 子组件：beforeCreate → created
- **顺序**：父组件的 beforeCreate 和 created 先执行，子组件的 beforeCreate 和 created 后执行

#### 2. 挂载阶段

- 父组件：beforeMount
- 子组件：beforeMount → mounted
- 父组件：mounted
- **顺序**：父 beforeMount → 子 beforeCreate → 子 created → 子 beforeMount → 子 mounted → 父 mounted

#### 3. 更新阶段

- 父组件：beforeUpdate
- 子组件：beforeUpdate → updated
- 父组件：updated
- **顺序**：父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated

#### 4. 销毁阶段

- 父组件：beforeDestroy
- 子组件：beforeDestroy → destroyed
- 父组件：destroyed
- **顺序**：父 beforeDestroy → 子 beforeDestroy → 子 destroyed → 父 destroyed

## 四、Vue 指令和语法

### v-show 和 v-if 的区别

- **渲染方式**：
  - `v-if`：条件为 true 时才会渲染元素，条件为 false 时销毁元素
  - `v-show`：始终渲染元素，只是通过 CSS 控制 display 属性来显示或隐藏
- **适用场景**：
  - `v-if`：适用于条件变化不频繁的场景
  - `v-show`：适用于条件变化频繁的场景

### 为什么 v-if 和 v-for 不能一起使用

- 由于 v-for 的解析优先级高于 v-if，同时使用时，Vue 首先会循环创建所有 DOM 元素，然后根据条件来判断是否渲染每个元素
- 这种方式可能导致 Vue 进行大量的 DOM 操作，性能较差
- v-for 会为每个循环项创建一个新的作用域，而 v-if 的条件如果依赖于这个作用域内的数据，可能导致判断逻辑异常
- **解决方案**：将 v-if 放到 v-for 外层，或者将 v-if 放置到 v-for 内部的单个节点上

## 五、Vue 响应式系统

### watch 和 watchEffect 的区别

#### 依赖追踪方式

- **watch**：需要显式声明依赖，监听指定的数据源；可以监听多个数据源或进行深度监听
- **watchEffect**：会自动追踪作用域内所有的响应式依赖，不需要显式声明依赖

#### 执行时机

- **watch**：在监听的响应式数据变化后立即执行
- **watchEffect**：在组件挂载时执行一次副作用，并在依赖发生变化时再次执行

#### 适用场景

- **watch**：适用于监听特定数据变化并执行副作用的场景，如 API 请求、保存操作等。适合需要访问新值和旧值进行比较的场景
- **watchEffect**：不需要访问旧值，适用于自动追踪多个响应式依赖的副作用，如渲染、自动保存等

### Vue3 中 ref 和 reactive 如何选择

#### reactive 的实现

- reactive 通过 Proxy 对对象或数组的每个属性进行深度代理，实现响应式
- 这种设计使得 reactive 能自动追踪所有嵌套属性的变化
- 由于 Proxy 无法直接处理基本数据类型（如 number、string、boolean），因此 reactive 不适用于基本数据类型

#### ref 的实现

- 为了实现基本数据类型的响应式，Vue 设计了 ref
- ref 会将基本数据类型封装为一个包含 value 属性的对象，通过 getter 和 setter 实现响应式依赖追踪和更新
- 当访问或修改 ref.value 时，Vue 内部会触发依赖更新
- 对于复杂数据类型（如对象或数组），ref 的内部实现会直接调用 reactive，将复杂数据类型变为响应式

#### reactive 的限制

1. **有限的值类型**：它只能用于对象类型（对象、数组和如 Map、Set 这样的集合类型）。它不能持有如 string、number 或 boolean 这样的原始类型
2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用
3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接

## 六、Vue 组件特性

### 什么是动态组件，如何使用它

- 动态组件是 Vue 提供的一种机制，允许我们根据条件动态切换渲染的组件，而不需要手动修改模板
- 在 Vue 中，我们可以通过 `<component>` 标签的 `:is` 属性指定需要渲染的组件

#### `<component>` 标签的 `:is` 属性值可以是：

1. 被注册的组件名
2. 导入的组件对象
3. 一般的 HTML 元素

当使用 `<component :is="...">` 来在多个组件间作切换时，被切换掉的组件会被卸载。如果需要保留动态组件状态，使用 `<KeepAlive>` 组件即可。

### 什么是 slot？有什么应用场景？

在 Vue 中，插槽的使用方式可以分为四种：默认插槽、具名插槽、条件插槽和作用域插槽

#### 应用场景

1. **灵活的组件内容插入**：插槽允许我们将内容插入组件中，而无需修改子组件内部逻辑，极大提高了组件的灵活性
2. **构建通用组件**：比如开发卡片、模态框、列表等组件，使用插槽可以轻松实现内容的自定义。模态框组件可通过插槽自定义标题、正文和按钮
3. **减少重复代码**：通过插槽，将公共逻辑封装到子组件中，而在父组件中只需插入变化的内容

### 什么是 nextTick，如何应用它

在 Vue.js 中，nextTick 是一个核心工具方法，用于处理 DOM 更新时机问题。它的核心作用是：在下次 DOM 更新循环结束后执行回调，确保我们能操作到最新的 DOM 状态。

### 自定义组件如何实现 v-model

从 Vue 3.4 开始，官方推荐的实现方式是使用 `defineModel()` 宏：

- defineModel 是一个便利宏，其返回的值是一个 ref
- 它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用
- 它的 .value 和父组件的 v-model 的值同步
- 当它被子组件变更了，会触发父组件绑定的值一起更新
- 根据 defineModel 的特性，我们可以用 v-model 把这个 ref 绑定到一个原生 input 元素上

## 七、Vue 原理

### 什么是 MVVM

MVVM（Model-View-ViewModel）是一种用于构建用户界面的架构模式，用于现代的前端开发框架（Vue、Angular）。它通过数据绑定和视图模型提供了高效的 UI 更新和数据同步机制。

MVVM 模式主要由 Model（模型）、View（视图）、ViewModel（视图模型）三个部分组成：

- **Model**：表示程序的核心数据和业务逻辑，它不关心用户界面，只负责数据的获取、存储和处理，并提供与外界交互的接口
- **View**：负责展示数据和用户交互，简单来说就是我们看到的UI组件或HTML页面
- **ViewModel**：是连接 View 和 Model 的桥梁，它不直接操作视图或模型，而是通过数据绑定将两者连接起来

### 什么是 VDOM，它和 DOM 有什么关系

VDOM（Virtual DOM，虚拟 DOM）是 DOM 渲染的一种优化，它是一个内存中的虚拟树，是真实 DOM 的轻量级 JavaScript 对象表示。

VDOM 主要用于优化 UI 渲染性能，它的工作流程大致如下：

1. **创建虚拟 DOM**：当组件的状态或数据发生变化时，Vue 会重新生成虚拟 DOM
2. **比较虚拟 DOM 和真实 DOM**：Vue 使用一种高效的算法来比较新旧虚拟 DOM 的差异（即 diff 算法）
3. **更新 DOM**：根据差异更新真实的 DOM，仅修改有变化的部分，而不是重新渲染整个 DOM 树

### Vue 组件初始化的各个阶段都干了什么

1. **组件实例创建**：当我们第一次访问页面时，Vue 创建组件实例，解析 props、data、methods 等属性方法，在组合式 API 中，执行 setup()
2. **响应式系统建立**：基于 Proxy 实现 reactive、ref，建立依赖收集和触发更新机制，props 传递时自动响应式处理
3. **模板编译与渲染**：将 template 编译为渲染函数，Vue 3 通过静态提升等方式优化性能，Vite 预编译 SFC（单文件组件）
4. **DOM 挂载**：执行渲染函数生成 VNode，通过 Patch 算法转换为真实 DOM 并插入页面，同时初始化子组件。mounted（Options API）或 onMounted（Composition API）触发，可进行 DOM 操作
5. **响应式更新**：状态变更触发 Diff 算法计算最小 DOM 更新，beforeUpdate、updated（Options API）或 onBeforeUpdate、onUpdated（Composition API）执行相应逻辑
6. **组件销毁**：移除 DOM，清理副作用（解绑事件、销毁 watcher、清理 effect），递归卸载子组件，触发 beforeUnmount、unmounted（Options API）或 onBeforeUnmount、onUnmounted（Composition API）

### Vue 如何实现数据的双向绑定（响应式原理 + v-model 原理）

Vue 双向数据绑定的核心原理是数据劫持结合发布-订阅模式，通过以下流程实现：

#### 1. 数据劫持（响应式系统）

- Vue 2 使用 Object.defineProperty 对数据对象每个属性添加 getter/setter 拦截
- Vue 3 改用 Proxy 代理整个对象，直接监听对象层级变化
- 数据变化时能触发监听逻辑

#### 2. 依赖收集与派发更新

- 每个组件实例对应一个 Watcher 观察者
- 初次渲染时触发数据 getter，通过 Dep 类收集依赖（记录哪些数据被使用）
- 数据变化时通过 setter/Proxy 触发 Dep 通知所有关联 Watcher

#### 3. 双向绑定实现

- **数据→视图**：虚拟 DOM 对比更新真实 DOM
- **视图→数据**：通过 v-model 语法糖自动添加 @input 事件监听表单元素，修改对应数据

#### 补充关键点

- v-model 本质是 :value + @input 的语法糖
- Proxy 相比 defineProperty 优势：直接监听对象/数组变化、无需递归初始化、性能更好

### Vue 模板编译的过程

Vue 的模板编译过程是将开发者编写的模板语法（例如 v-if 和 v-bind 等）转换为 JavaScript 代码的过程。它主要分为三个阶段：模板解析、AST优化和代码生成：

#### 1. 模板解析

Vue 使用其解析器将 HTML 模板转换为抽象语法树（AST）。在这个阶段，Vue 会分析模板中的标签、属性和指令，生成一颗树形结构。每个节点表示模板中的一个元素或属性。

#### 2. AST 优化

Vue 在生成渲染函数前，会对 AST 进行优化。优化的核心目标是标记静态节点，在渲染时，Vue 可以跳过这些静态节点，提升性能。（静态节点指所有的渲染过程中都不变化的内容，比如某个 div 标签内的静态文本）

在 Vue3 中，如果一个节点及其子树都不依赖于动态数据，那么该节点会被提升到渲染函数外部（静态提升），仅在组件初次渲染时创建。

#### 3. 代码生成

生成渲染函数是编译的最终阶段，这个阶段会将优化后的 AST 转换成 JavaScript 渲染函数。渲染函数的返回值是一个虚拟 DOM（VDOM）树，Vue 会根据虚拟 DOM 来更新实际的 DOM。

### Vue 的响应式原理

Vue 的响应式原理核心是通过数据劫持结合发布-订阅模式实现的，分为三步：

#### 数据劫持（监听变化）

- Vue 2 使用 Object.defineProperty 递归遍历对象属性，将属性转为 getter/setter
- Vue 3 改用 Proxy 代理整个对象，拦截属性的读取（get）和修改（set），无需递归初始化

#### 依赖收集（追踪依赖）

当组件渲染或计算属性执行时，触发数据的 getter，Vue 通过 Dep 类（Vue 2）或 effect 副作用函数（Vue 3）收集当前依赖（如视图更新函数），建立数据与依赖的映射关系。

#### 派发更新（触发更新）

当数据变化时，触发 setter 或 Proxy 的 set 拦截，Vue 通知关联的依赖（如组件渲染函数），触发虚拟 DOM 的重新渲染和页面更新。

### 为何 v-for 需要使用 key

1. **提高性能**：当 Vue 更新视图时，它会根据 key 来识别哪些元素被修改、添加或移除。如果没有 key，Vue 会依赖其默认的算法（基于元素的位置）来比较元素，这样可能导致不必要的 DOM 操作。使用 key 后，Vue 能精确地找到每个项，从而减少不必要的 DOM 重排和重绘，提升性能
2. **保持组件状态**：如果渲染的是一个组件（而不是普通的 DOM 元素），使用 key 可以确保组件在渲染更新时保持正确的状态
3. **避免渲染错误**：key 确保在列表更新时，元素的顺序和内容保持稳定，避免出现不稳定的渲染或顺序错乱

### Vue diff 算法的过程

1. **同层比较**：仅对比同一层级的节点，若父节点不同，直接替换整个子树，不深入子节点
2. **节点对比**：如果新旧节点类型相同，则继续比较它们的属性。对于不同的属性值进行更新，移除旧属性，添加新属性。如果节点类型不同（如元素和文本节点不同），则直接替换整个节点
3. **子节点比对**：对于有子节点的元素（如 div），Vue 会使用不同的策略来优化子节点更新：如果新旧子节点都是文本节点，直接更新文本内容。如果新旧子节点都是数组，Vue 会采用 LIS 算法优化节点的重新排列，避免过多的 DOM 操作

### Vue3 的 diff 算法有哪些优化

1. **最长递增子序列（LIS）算法**：在处理节点更新时，利用最长递增子序列算法来优化对比流程。通过找到新旧节点之间的最长递增子序列，可以减少不必要的 DOM 操作，从而提高更新效率
2. **静态提升**：对于不参与更新的元素，将其提升为静态节点，仅在首次创建时进行处理，后续不再重复计算
3. **静态标记机制**：引入了静态标记机制，在模板编译阶段为静态节点添加标记，避免了对这些节点的重复比较
4. **类型检查和属性对比**：增加了类型检查和属性对比功能。如果节点类型不同，则直接替换；如果类型相同，则进一步对比节点的属性，生成更新操作
5. **动态内容标记**：在编译阶段，通过标记动态内容（如 class、style、props 等），让运行时比对时直接定位变化的部分，跳过无变化的节点

### 简述 Vue 组件异步更新的流程

#### 一、触发阶段：依赖收集与变更通知

1. **数据变更触发依赖通知**：当组件内响应式数据（如 data、props）被修改时，触发 setter 通知所有关联的 Watcher
2. **Watcher 入队缓冲**：所有关联的 Watcher 会被推入异步更新队列，通过 id 去重，确保每个 Watcher 仅入队一次，避免重复更新

#### 二、调度阶段：异步队列处理

3. **启动异步任务**：Vue 将刷新任务放入微任务队列（优先 Promise.then，降级 setImmediate 或 setTimeout），等待当前同步代码执行完毕后处理。同一事件循环中的多次数据变更会被合并为一次组件更新（如循环中修改数据 100 次，仅触发 1 次渲染）

#### 三、执行阶段：虚拟 DOM 与 DOM 更新

4. **组件重新渲染**：执行队列中的 Watcher 更新函数，触发组件的 render 生成新虚拟 DOM。通过 Diff 算法对比新旧 VNode，计算出最小化 DOM 操作，批量更新真实 DOM

### Vue 组件是如何渲染和更新的

#### 一、组件渲染流程

1. **模板编译**：Vue 将 template 解析为 AST。AST 经过优化（如静态节点标记）后，生成渲染函数（render 函数）
2. **响应式数据初始化**：初始化组件实例，通过 Object.defineProperty 或 Proxy 将数据转为响应式。为每个组件实例创建渲染 Watcher，用于追踪数据依赖
3. **生成虚拟 DOM**：执行 render 函数，返回虚拟 DOM，描述真实 DOM 结构
4. **挂载真实 DOM**：将虚拟 DOM 转换为真实 DOM，插入页面，触发 mounted 生命周期钩子

#### 二、组件更新流程

1. **数据变更触发依赖**：修改响应式数据时，触发 setter 或 Proxy 拦截，通知关联的 Watcher
2. **异步更新队列**：Watcher 将更新任务推入异步队列，避免重复渲染
3. **重新生成虚拟 DOM**：执行 render 函数生成新虚拟 DOM 树
4. **Diff 算法对比差异**：对新旧虚拟 DOM 进行同级比较，高效找出差异
5. **更新真实 DOM**：将差异应用到真实 DOM，触发 updated 生命周期钩子

### 为何 ref 需要 value 属性

Vue 3 中，ref 之所以需要 .value 属性，主要是因为 Vue 3 使用 Proxy 实现响应式。Proxy 对对象或数组的每个属性进行深度代理，因此可以追踪嵌套属性的变化。而 Proxy 无法直接处理基本数据类型（如 number、string、boolean），这使得 reactive 无法用于基本数据类型。

为了实现基本数据类型的响应式，Vue 设计了 ref，它将基本数据类型封装为一个包含 value 属性的对象，并通过 getter 和 setter 进行依赖追踪和更新。当访问或修改 ref.value 时，Vue 会触发依赖更新。

### 为什么 Proxy 可以更好地支持数组和动态新增属性？

Proxy 能更好地支持数组和动态新增属性，主要体现在：

#### 1. 数组的响应式监听

- 传统 Object.defineProperty 需要重写数组方法（如 push）才能监听变化，且无法直接检测索引赋值（如 arr[2] = 1）或 length 修改
- Proxy 直接拦截数组的索引操作、方法调用和 length 变化，无需额外处理，实现全面的监听

#### 2. 动态新增属性

- Object.defineProperty 需预先定义属性，后续新增的属性无法自动响应
- Proxy 拦截的是整个对象，无论属性是否存在，新增属性时 set 拦截器会被触发，天然支持动态属性

#### 对比总结

Proxy 通过拦截对象的所有操作（如 get/set/deleteProperty 等），提供更全面的响应式支持，而无需针对数组或动态属性做特殊处理，降低了维护成本。

## 为什么选择pinia，pinia和vuex的设计模式区别