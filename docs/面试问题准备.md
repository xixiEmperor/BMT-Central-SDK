# HTML

## 1.怎么利用语义化标签进行页面内容优化

1. 用header包裹头部相关部分
2. 用aside包裹侧边栏相关部分
3. 用footer包裹页脚部分
4. 中间部分用section包裹，里面要有标题
5. 整个页面的标题等级应该从大到小，不应跳级
6. 一个页面中应该最多只有一个main，包裹最核心内容

## 2.script 标签里 async/defer 分别是什么意思 *2

1. async：当在html给script加入async属性后，当浏览器解析到script标签时，会异步解析js，解析后直接执行js代码，执行js可能会发生在html解析完之前，也可能在之后，不阻塞页面UI渲染
2. defer：当在html中给script加入defer属性后，同样会异步解析js，只不过在解析完成后需要等待html解析并渲染完毕后再执行，当有多个script中包含defer时，执行顺序按从上到下的顺序进行

# CSS

## 1.水平垂直居中有哪些做法 * 5

1. 绝对定位+translate (不需要知道宽高)
   {
   position: absolute;
   transform: translate(-50%, -50%);
   top: 50%;
   left:50%;
   }
2. 绝对定位 + margin:auto(不需要知道宽高)
   {
   position: absolute;
   top: 0;
   left: 0;
   bottom: 0;
   right: 0;
   margin: auto
   }
3. flex布局(不需要知道宽高)
   {
   display: flex;
   justify-content: center;
   align-items: center;
   }
4. 绝对定位 + margin负值（需要知道宽高，原理类似2）
5. grid布局
   {
   display: grid;
   justify-content: center;
   align-items: center;
   }

## 2.选择器优先级排序 *3

!important > 内联样式 > id选择器 > 类选择器，伪类选择器，属性选择器 > 标签选择器，伪元素选择器

## 3.flex布局和grid布局的区别 * 3

flex布局：是一维布局模型，一次只控制一条轴线上的对齐方式，适用于对局部内容进行布局
grid布局: 是二维布局模型，一次可以控制两条轴上的对齐方式（行和列），适用于对页面整体结构进行布局

## 4.BFC概念：介绍一下BFC，哪些条件能产生 BFC？ *3

1. BFC概念：BFC即块级格式化上下文，BFC中的内容与外部内容互不相干，是一个独立的渲染区域
2. BFC特点：
   - BFC中的相邻margin会重叠，比如上下两个BFC分别设置了mb和mt,这两个margin不会同时生效，而是取较大值
   - BFC中的块级元素会在纵向依次排列，行内元素会在横向依次排列
   - BFC区域不会与浮动盒子重叠
   - BFC在计算高度时会包含内部浮动元素的高度
   - BFC内部的渲染与外部的渲染毫不相干，是一个独立的渲染容器
3. 触发BFC的条件：
   - 根元素（html元素）
   - overflow不为visible
   - position为absolute,fixed
   - display为flex,grid,inline-block,inline-flex,inline-grid等
   - float不为none

## 5.CSS中的几种定位（position）有什么区别？ *2

1. static: 默认值
2. relative: 元素相对于自身原来位置位移，不会脱离标准流
3. absolute: 元素相对于最近的非static祖先元素进行位移，会变为定位文档流
4. fixed: 固定定位，固定在视口的某个位置，会脱离标准文档流，变为定位文档流
5. sticky: 在一定高度内表现为relative，超过该高度变为fixed

## 6.行内元素和块级元素的区别

1. 排列方式：行内元素在一行中依次排列，宽度由内容撑开，块级元素默认独占父元素宽度的100%，在纵向依次排列
2. 宽高：行内元素不能设置宽高，高度和宽度均由内容撑开，块级元素可以设置宽高
3. 内外边距：行内元素纵向margin，padding不生效，横向的可以生效，块级元素均生效
4. 子元素：行内元素一般只能包括文字或其他行内元素，块级元素什么都可以包括

## 7.flex 1 具体值，flex 的三个值代表什么,flex: 2  的完整含义 *2

1. flex：1具体值为flex：1 1 0%
   分别为：
   - flex-grow: 表示flex元素的扩展比例，如果对同级别多个flex元素设置，则会按比例进行扩展
   - flex-shrink: 表示flex元素的缩小比例，是当flexbox无法容纳子元素且不设置换行时计算元素具体缩小宽度的重要权重因子
   - flex-basis: 表示flex元素的初始尺寸
     当父盒子无法承载子元素时，每个元素的缩小尺寸的计算方式为：flex-basis * （flex-shrink * flex-basis）/（所有元素shrink * basis）之和
     flex：1的效果为占满父盒子剩余尺寸，因为只有该元素有扩展系数，且basis为0，也就是忽略其本身尺寸，直接扩展
2. flex: 2: flex: 2 1 0

## 8.哪些方式可以解决 margin 塌陷？

1. 用padding代替margin
2. 设置一个极细的透明边框，可以隔绝两个margin重叠的部分
3. 设置BFC -> 引出触发BFC的几种方式

## 9.弹性布局。

## 10.响应式布局。

1. flex布局
2. grid布局
3. 一些单位：%，em，rem，vh，vw
4. 媒体查询

## 11.css框架问题，用过tailwinds吗，讲一下sass的使用和传统css的对比。

1. 传统css与css预处理器的对比：传统css是浏览器可以直接理解的语言，可以用其直接编写样式，灵活性很强，但是缺少变量，函数等功能，而且在全局样式中很容易发生类名冲突，当项目规模较大时，不便于管理；而css预处理器解决了传统css的一些痛点，比如添加了变量，函数等功能，而且支持嵌套，可以更清晰的看出类与类之间的关系，不过最后仍需要将其编译为传统css，预处理器只是提升开发体验的工具。
2. css框架是建立在传统css或者css预处理器的基础上的，他提供的是现成的解决方案，通过封装好一些工具类，开发者可以直接使用这些工具类，而且避免了起类名困难，类名容易冲突等缺点，而且所见即结构，使得整个html模板的结构更加清晰。不过他也有缺点，因为缺少明确的类名，所以当项目规模过大的时候可能难以维护，而且预处理器在css动画的编写上开发体验是优于框架的。
3. 所以我认为最好的用法是结合css预处理器和css框架，简单样式用css框架，需要模块化或者高复用的样式用css预处理器进行编写。

## 12.visibility: hidden 、 display: none 、 opacity: 0  的核心区别

| 特性                   | display: none  | visibility: hidden                              | opacity: 0                                        |
| ---------------------- | -------------- | ----------------------------------------------- | ------------------------------------------------- |
| 是否在文档流中占据空间 | 不占据         | 占据                                            | 占据                                              |
| 是否响应点击等交互事件 | 不能           | 不能                                            | 可以（子元素可设置 pointer-events: none; 来禁止） |
| 是否可以被子元素"逆转" | 否             | 可以（子元素设置 visibility: visible 即可显示） | 否（子元素会继承透明度，无法单独设为1来显示）     |
| 是否触发重排           | 是（改变布局） | 否（只触发重绘）                                | 否（大多数现代浏览器优化为复合操作，性能最好）    |
| 是否触发重绘           | 是             | 是                                              | 是（但属于高效复合层）                            |
| 屏幕阅读器是否可访问   | 不可访问       | 不可访问                                        | 可以访问（元素仍在DOM中）                         |

## 13.CSS的盒模型

## 14.CSS-in-JS 与传统 CSS 有什么区别？

# JS

## 1.js 的函数是怎么传递参数的（值传递还是引用传递）

1. 如果传递的参数是基本数据类型，就是值传递
2. 如果传递的参数是引用数据类型，就是引用传递

## 2.let var const const声明什么才可以改动 为什么

1. let和const会产生块级作用域，var不会，避免了全局变量污染的问题
2. var声明的变量会进行变量提升，let和const不会
3. let和var声明的变量的值可以更改，const只能声明常量
4. let和const会有暂时性死区(TDZ)，在声明变量前使用变量会报错ReferenceError，var不会，只会报错undefined
5. let和const声明的变量不能重复声明，否则会报SyntaxError,var声明的变量可以被重复声明覆盖

const声明引用数据类型才可以改动，因为const声明引用数据类型时，变量实际上存储的值是该引用类型的地址，我们改动对象的属性改动的是堆内存里的实际值，而不是这个变量的地址，如果对const声明的对象进行整个对象的替换，同样会报错，因为改变了地址数据

## 3.js的数据类型 * 5

1. 基本数据类型(7种):number,string,boolean,undefined,null,symbol,bigint
2. 引用数据类型(3种):object,function,array

## 4.形参和实参

1. 形参: 可以简单理解为参数的占位符，并没有实际意义，当外界调用函数传入实参的时候，形参所在的位置会换成传入的真实数据
2. 实参：函数调用时传入的真实数据

## 5.闭包 *3

概念：我认为可以理解为，一个函数有权使用另一个函数作用域中的变量，可以通过在一个函数中声明一些变量和一个内层函数，在这个内层函数中使用这些变量并返回来实现一个简单的闭包。
应用场景：

1. 工厂函数
2. 私有变量的封装
3. 定时器

## 6.Set和普通数组有什么区别？

1. Set里面不能装重复的元素，普通数组可以
2. Set里面的元素不能通过索引进行访问，普通数组可以
3. Set的查找和删除性能更好，时间复杂度为O(1), 普通数组为O(n)
4. Set只支持forEach和for of遍历，普通数组还可以通过数组方法比如filter，map，reduce进行遍历

## 7.JavaScript的垃圾回收机制 *5

1. 引用计数法

- 在堆内存中创建新的变量，该变量被新的地址指向时，计数会+1
- 当该变量不再被一个地址指向时，计数-1
  当一个变量的计数减到零的时候，该变量会自动被当做垃圾变量回收

2. 标记清除法

- 首先对所有变量进行标记，将其标记为0
- 然后从根对象开始进行遍历，对所有可以遍历到的对象标记为1,
- 遍历完成后，将所有变量不为1的变量进行垃圾回收，回收完后将所有存活对象重新全部标记为0

3. 新生代老生代
   新生代：存放存活时间较短的变量

- 新生代中有两个区域：to区域和from区域。新来的变量会被放在from区域中，当from区域内存满后，执行一次垃圾回收，回收后交换to和from区域，旧的from变为新的to
- 具体的垃圾回收过程如下：
  - 设置分配指针和扫描指针
  - 从根对象开始遍历，对于每个根对象直接引用的from区域的对象，会将该对象复制到to区域，并在原from区域留下一个转发指针，指向其新位置，然后更新根对象中的引用
  - 使用扫描指针对每个已经复制到to区域的对象进行扫描，如果其内部引用了from区域的变量，看看其有无转发指针，如果有，则直接将其复制到转发指针指向的新地址，如果没有，则将其复制到to区域并在原位置留下转发指针，重复这个过程直到扫描指针追上分配指针(说明根对象中变量已全部更新)
  - 对于to区域中达到一定次数的变量，或者to空间占用率达到一定阈值的对象，或者是大对象，会将其推向老生代

老生代：存放存活时间较长的变量

- 当老生代区域的内存使用率较高的时候，会触发垃圾回收，老生代的垃圾回收使用的是标记整理算法，具体流程如下：
  - 标记过程与标记清除的过程相同
  - 不同的是，整理过程中，会将所有存活的变量推向一边，这就意味着他们的地址发生了变化
  - 此时就需要遍历整个对象图，更新所有引用，将所有变量指向对象的新地址
  - 然后会将分配指针移动到最后一个引用之后，当下一次分配内存时，就从分配指针当前的位置开始分配新内存

需要注意的是，标记整理过程并没有直接处理垃圾，而是通过地址指向的值重新覆盖的方式进行垃圾回收

## 8.箭头函数和普通函数的区别 *8

1. 箭头函数没有arguments
2. 箭头函数没有this，箭头函数的this是继承父级的this
3. 箭头函数没有prototype，不能作为构造函数
4. 箭头函数不能被call，apply，bind绑定this

## 9.通过哪些方法可以判断一个变量是数组类型？*2

1. Array.isArray()
2. Object.prototype.toString.call(obj)
3. obj instanceof Array
4. obj.__proto__ === Array.prototype

## 10.如何实现并发请求？Promise.all的实现原理是什么？*2

1. 可以通过Promise里面的all,allSettled,race来进行并发请求
2. all的实现原理为：
   - 外部传入一个Promise数组
   - 内部会通过try...catch..逐个调用Promise
   - 如果成功调用，那么将结果加入到一个数组中
   - 如果调用失败，直接进入catch，调用reject抛出错误
   - 当在try中实现已调用数量等于数组数量时，调用resolve进行下一步操作

## 11.async/await和Promise有什么区别？了解它和Generator的关系吗？

1. async/await是Promise的语法糖，async会将一个函数包装成该函数内部返回Promise的情况，所有函数体里的逻辑都会被包裹在返回的Promise中，用async声明的函数在调用时可以在前面加上await来阻塞代码执行，当使用await时，必须等待await声明的操作的内部调用resolve才会解除阻塞，并将后续的代码包装成一个微任务，否则后续代码将不会执行。
2. 

## 12.ES6的new操作符

new操作符用来创建一个构造函数的实例对象，内部原理如下：

1. 创建一个新的空对象
2. 将该新对象的__proto__指向构造函数的prototype
3. 通过调用call方法来调用构造函数，并通过一个变量接收可能存在的返回值
4. 判断构造函数是否返回了一个对象，如果是，就返回该对象，如果不是，就返回一开始创建的新的空对象

## 13.宏任务和微任务的区别，任务队列，事件循环的理解 *6

浏览器在执行js代码的过程中会将其分为三种类型，分别为：

1. 同步代码，解析到的时候就执行
2. 微任务，解析到之后将其加入微任务队列
3. 宏任务，解析到之后将其加入宏任务队列

对于这三种任务，浏览器首先会执行完所有的同步代码，然后以微任务优先为原则，在执行宏任务之前，一定会清空微任务队列，当执行宏任务的时候又碰到了微任务，会将其加入微任务队列，并在该宏任务执行完后，再次清空微任务队列，直到所有任务执行完毕

## 14.== 与 === 的区别

1. == 是值相等，类型可以不相等
2. === 是值和类型都相等

## 15.ES6 里面，它相对于 ES5 里面新增了很多 API

1. class
2. Promise
3. 箭头函数
4. Map，Set
5. 解构赋值
6. 模板字符串
7. Proxy

## 16.js如何捕获异步任务异常

1. Promise里面的then，catch
2. try...catch...
3. window.onerror(message,source,lineno,colno,error)

## 17.js有哪些报错？哪些异常类型？

1. ReferrenceError,查找错误，会在使用const和let声明变量前使用变量触发，或者是在作用域中找不到变量时触发
2. SyntaxError，语法错误，使用错误的语法时会触发
3. TypeError，类型错误，错误使用变量的类型时会触发，比如将一个number变量当做函数调用
4. RangeError，范围错误，超出数据的范围时会触发，比如数组长度过大，递归深度过大

## 18.js为什么计时不准确？如何相对准确计时？*2

计时不准确原因：

- 事件循环机制会阻塞定时器，如果在同步代码中遇到长任务比如复杂的时间计算，次数较大的循环，会导致
- 浏览器为了节省设备用电消耗，会将定时器的最小延迟设置为4ms，即使我们设置的延迟是0
- 用户的一些行为可能会插队，导致定时器延迟，比如点击事件
- Date.now()依赖用户系统时钟，如果系统时钟不准确，同样会导致计时不准确

解决方案：

- 使用Performance.now()的相对时间代替Date.now()
- 使用Web Worker，使得计时相关操作不被主线程影响
- 自补偿递归，递归使用setTimeout动态计算延迟，而不使用setInterval
- css动画使用requestAnimationFrame

## 19.Promise以及相关API，async，await的理解（极其重要）

## 20.浏览器各种worker (后面慢慢学)

## 21.哪些操作容易造成内存泄漏。*2

1. 闭包中的变量，不需要时可以手动将其设为null
2. 未清除的定时器
3. 未移出的事件监听器
4. 被保留的dom引用
5. 意外声明的全局变量

## 22.怎么判断一个对象是空对象？

1. Object.keys()会返回一个包含对象所有属性的数组，如果数组的长度为0说明是空对象
2. JSON.stringfy将对象转成json字符串，如果是'{}'则是空对象
3. 使用for...in... 循环，在循环中调用obj.hasOwnProperty(key)，如果能拿到东西说明不是空对象
4. 使用Object.getOwnPropertyNames()，类似方法1

## 23.symbol的键怎么获得呢？

1. 调用obj.getOwnPropertySymbols()，返回所有symbol键组成的数组
2. 调用Reflect.ownKeys(obj)，类似Object.keys()，但前者的返回值包括了symbol，后者不含symbol

## 24.Proxy和Reflect分别是什么

1. Proxy是一个代理，用于代理一个普通对象，在Proxy中，他会拦截我们对普通对象的各种操作，常见的有get，set操作，在里面可以定义我们在读写数据之前的一些预先行为，一般可以拿到的参数有：target(代理的对象)，key(被拦截的属性)，value(写入操作时写入的值)，receiver(指向接收属性赋值操作的对象)
2. Reflect是反射，是js中的一个内置对象，里面存储了大量的分散的静态方法，在Reflect出来之前，各种默认方法分散在各个数据类型中，而Reflect就是用来整理这些默认行为，让他们有集合的地方。
3. 在Proxy中对数据进行拦截的过程中，如果我们要进行一些默认操作，最好的做法就是使用Reflect里面的静态方法，Proxy可拦截的操作在Reflect里面均有对应的静态方法，比如get和set

## 25.有哪些宏任务，哪些微任务？*2

1. 宏任务: setTimeout，setInterval，浏览器UI渲染，文件I/O操作，requestAnimationFrame
2. 微任务: MutationObserver，then，catch，finally，await后续的代码

## 26.js的同步异步，js为什么要实现异步,什么场景下使用异步？ *2

1. 同步：代码按照书写顺序依次执行，前一个任务完成后才会进行下一个任务
2. 异步：代码不会阻塞后续代码的执行，而是在满足特定条件时执行回调
3. 实现异步的原因：
   - 同步代码会阻塞后续代码执行导致阻塞UI渲染
   - 网络请求，文件读写等操作耗时较长，会长时间阻塞代码运行
4. 使用异步的场景：
   - 网络请求
   - 文件读写
   - 定时器
   - 用户交互事件

## 27.深拷贝 浅拷贝

1. 浅拷贝是只复制对象的第一层属性，而不复制对象的更深层次属性
2. 深拷贝是复制对象所有层级的属性
   浅拷贝可能带来的负面效果：
   - 当我们修改一个拷贝对象的深层属性时，原对象的属性也会被一同修改，因为拷贝的对象与原对象的深层次属性仍然指向同一个地址

## 28.介绍下节流和防抖

1. 节流：节流是指在一段时间内，无论事件触发多少次，回调函数只执行一次
2. 防抖：防抖是指在事件被触发后，等待一段时间再执行回调，如果等待期间又被触发，则重新计时

## 29.原型链是如何实现继承的？能写个例子吗？*2

1. 原型链的继承是通过将实例的__proto__指向其构造函数的prototype实现的继承
2. 实现继承的方法有：
   ------------------

## 30.继承的含义是什么？

## 31.Function 的原型是什么？为什么是这样？

## 32.JS 的长任务阻塞页面渲染，如何优化

1. 将长任务分解成多个小任务
2. 使用setTimeout或者Promise异步执行任务
3. 使用requestIdleCallback在浏览器空闲时执行任务
4. 懒加载，初始加载时只加载首屏的资源，后续当元素出现在视口时才去进行相应资源的请求

## 33.什么时候会发生栈溢出

1. 无限递归
2. 递归深度过大
3. 分配数组长度过大
4. 函数调用层级过深

## 34.js类型判断

1. typeof
2. instanceof
3. Object.prototype.toString()

## 35.map跟对象的区别

1. map的键类型可以是任意，对象的键类型只能是string或者symbol
2. map里面的键值对顺序是严格按照添加顺序，对象中无法严格保证顺序
3. map用for of遍历，对象只能用for in遍历
4. 获取键的方式
5. 获取长度大小的方式，map.size可以直接获得长度，普通对象需要通过Object.keys(obj).length

## 36.apply , call ,bind的区别

1. apply和call主要是参数传递方式有区别，他们的第一个参数都是要显示绑定的this，第二个参数，apply需要传数组，call不止两个参数，后面所有参数都是相当于apply的参数数组扩展开
2. bind是显式绑定一个this，但不会直接调用函数，会返回一个绑定了this的函数，我们需要通过一个变量接收这个新函数并自己调用

## 37.typeof和 instanceof 区别？

1. typeof是判断一个变量的类型，返回该变量的数据类型
2. instanceof是判断某个构造函数是否出现在一个变量的原型链上，返回一个布尔值

## 38.数组和对象在类型判断上怎么区分？比如你现在写一个通用的函数去区分 null、数组、普通对象，怎么来实现

1. 通过Array.isArray(obj)来判断返回的是否是true，true则表示是一个数组
2. 通过Object.prototype.toString.call(obj)的返回值判断，当obj是一个引用数据类型时，会返回[object null(或者object,array)]

## 39.你知道typeof null是什么结果吗？那为什么是object

1. 结果：Object
2. 原因：第一版的js使用的是32位的存储单元，判断一个变量是否是对象是通过其机器码的前三位是否是000，如果是，则是一个对象，那null是一个空，机器码肯定是全0，所以就会被判断为一个Object

## 40.说一下 JS 里比较精确的类型判断方法

1. Array.isArray()
2. Object.prototype.toString.call()
3. instanceof
4. typeof

## 41.那typeof []是什么？typeof {} 呢？怎么区分它们俩

都是Object，区分方法参上

## 42.用 JavaScript 计算 FPS核心原理是什么

## 43.stringify实现深拷贝会遇到什么问题

# TS

## 1.Ts的keyof、typeof、泛型、装饰器；ts在前端工程化有什么作用呢

1. keyof返回一个对象的所有键的类型，返回值是一个联合类型
2. typeof返回一个对象内部所有键值对的类型，返回值是一个联合类型
3. 泛型可以理解为一个类型参数，当在一个接口或者类中传入一个泛型时，其内部数据均可以使用这个传入的类型
4. 装饰器
5. ts在前端工程化中的作用：
   - 当项目体积越来越庞大时，清晰的类型接口可以让项目更容易维护
   - 若代码出现类型错误，在编译时就会报错，而不是在运行中报错
   - 代码的可读性更高，可以让没有接触过该项目的新人更容易掌握代码的结构
   - 当鼠标悬浮在类型上时会弹出类型提示，不需要反复查找某个数据应该如何使用

## 2.ts的any unknown null什么区别

1. any是完全绕过类型检查，该变量可以是任何类型，编译时不会报类型错误，后续该数据也可以正常使用
2. unknown只是暂时避免类型检查，后续使用该变量时需要进行类型收窄，否则会报错，因此更安全
3. null是空对象

## 3.interface和type区别 *2

1. interface用来定义一个类型接口，一般是用于定义一个对象结构的类型
2. type用来定义一个类型别名，一般用于联合类型和交叉类型和基础类型，还可以被typeof赋值

## 4.如何提取一个函数类型的返回类型？了解哪些 TypeScript 的工具类型函数？

1. 用工具函数ReturnType<>,泛型传入返回值
2. 工具类型函数：
   - Pick
   - Omit
   - Include
   - Exclude
   - Partial
   - Require
   - Record
   - Readonly
   - Parameters
   - ReturnType

## 5.讲下enum

enum用来声明一个枚举类型，一般是用于定义一些常量，常量的属性值一般是字符串或者数字类型

## 6.讲下ts的class的语法糖

1. 在constructor的参数里面对变量加入访问修饰符pubilc,protected,private,readonly,可以达到声明+赋值的效果
2. get和set声明的函数对同一个属性进行操作
3. abstract抽象类，一般用于操作一个基类，后续其他单独的类对其进行继承
4. 属性可以自动初始化，不需要通过传入参数才能初始化
5. static声明静态方法或属性

## 7.ts的readonly的原理是什么

# vue

## 1.computed和watch的区别

1. computed用于计算一些派生数据，watch用于监听某一特定数据源的变化，从而执行一些副作用
2. computed中计算出的数据会被缓存，只有当依赖的外部响应式数据变化了才会重新计算
3. watch不会缓存执行的副作用的返回值，每当监听的数据源发生变化，就会重新执行副作用
4. 因此computed的性能较好，watch的性能较差

## 2.对 Vue 3.6 的无虚拟 DOM 模式有什么理解

## 3.setup代替了vue2的哪些功能？

代替了vue2的两个声明周期钩子：beforeCreate, created

## 4.Vue&React比较,什么时候用哪个？他们的缺点是什么？ *8

1. vue更加偏向框架，像一个整理好的工具箱，官方提供了完整的解决方案，比如vue-router和pinia，采用了模板语法和响应式系统，新手上手更快，项目构建效率更高，适合中小项目快速搭建
2. react更加偏向原生js，强调函数式编程和单项数据流，使用jsx构建视图，搭配hooks和Typescript，项目的可维护性和扩展性很强，并且框架生态比vue更丰富，适合中大型项目
3. 当团队成员经验没那么丰富，且项目规模不大时，更偏向于用vue
4. 当团队成员能力较强，项目规模大，需要长期维护和扩展时，更偏向于用react
5. 二者缺点：
   - vue的生态较小，ts的支持不如react，vue的模板语法使其不如jsx灵活
   - react的数据传递较为繁琐，因为严格遵守单向数据流，学习成本较高，需要理解函数式编程，hook等概念，由于并没有官方提供的关于路由和状态的解决方案，团队成员还需要学习额外的库

## 5.Vue2与Vue3区别 *9

1. 性能优化方面：
   - vue3支持tree shaking，拥有更小的打包体积
   - vue3采用了更高效的diff算法
2. Composition Api：vue3采用Composition API，相比于vue2的选项式api，vue3的代码逻辑更加集中，可维护性和可读性更强，同时Composition API使得代码的复用性更强，减少了冗余代码
3. 响应式系统升级：
   - vue2通过Object.prototype.defineProperty()递归的为对象的每个属性添加get和set，性能消耗大
   - vue3通过Proxy对对象和数组进行代理，拦截get和set操作，无需递归遍历子属性，而且Proxy还可以解决vue2响应式系统中的存在的两个问题：一个是无法监听对象属性的新增和删除，一个是无法监听数组中直接通过索引修改数据，因为将数据转为响应式是在组件初始化阶段进行的，后续的属性就无法通过Object.prototype.defineProperty()实现响应式。但Proxy代理的是整个对象的读写操作，因此可以解决这两个问题。
4. vue3原生支持Typescript，类型推导更好
5. vue3可以返回多个根template
6. vue3中新增了Teleport和Suspense内置标签
7. vue2中两个生命周期钩子created和beforeCreate被setup代替

## 6.讲讲vue的双向绑定原理 *5

1. 首先是对数据进行响应式处理，vue3是通过proxy拦截数据的get和set操作，vue2是通过defineProperty递归遍历对象子属性为其添加get和set
2. 在将数据的读写操作拦截之后，当我们读取数据时，会触发proxy的get操作，在get操作中，vue会通过在proxy中使用Reflect.get获取相应的属性值，然后执行track函数，在track函数中，会从vue全局管理的一个weakmap中找到我们操作的这个对象，如果找不到，就在这个weakmap里面添加该对象的映射，该对象作为key，value是一个新的map，里面存储了属性到dep的映射。后续同样，找到这个对象的映射之后，找属性映射的dep类，如果找不到，就为该属性绑定一个dep类，然后执行dep类中的depend方法，在depend方法中，vue会进行dep和effect的双向绑定。
3. 当我们写入数据时，在proxy的set中会先拿到旧值，如果新旧值不同，则执行trigger函数，在trigger函数中，vue会找到我们操作的那个属性值对应的dep类，遍历所有订阅了该dep类的effect，先清理掉旧的依赖关系，然后去执行用户传入的副作用函数进行派发更新

## 9.讲讲Vue的Proxy，Vue3使用proxy会监听到子孙对象嘛

1. vue中的proxy是用来拦截一个对象或者数组的读写操作，为其进行数据的双向绑定，实现响应式更新
2. 会监听到子孙对象，因为他拦截的是整个对象，对对象中的任意层级的属性进行操作都会触发get或者set操作

## 11.Vuex vs. Pinia *4

1. pinia的包体积更小，相对vuex更加轻量
2. pinia原生支持Typescript，有更好的类型推导
3. pinia中没有mutation，无需像vuex中一样进行繁琐的同步异步操作
4. pinia中可以使用Composition API语法，对vue3使用者更友好，能够快速上手
5. pinia中一个文件就是一个模块，而vuex中需要单独管理modules

## 12.vue和react的虚拟dom如何构建

1. vue：
   - 首先进行模板编译，将模板编译为一个render渲染函数
   - 在组件进行首次渲染时，会执行render函数，生成VNode树
   - 当组件的数据发生变化时，会重新执行render生成新的虚拟dom树，然后通过diff算法比对新旧虚拟dom树，找出最小差异，然后批量更新真实dom

## 13.虚拟 DOM 有什么好处

1. 当数据发生变化时，如果直接去比对真实dom，会触发浏览器的重排和重绘，会耗费大量性能，如果只比对新旧虚拟dom，就可以把多次操作真实dom合并为一次或较少次数，避免了不必要的dom操作
2. 虚拟dom可以让开发者进行声明式编程，而不是命令式的直接操作真实dom
3. 因为虚拟dom在内存中表示为一个轻量级的js对象，因此虚拟dom并不依赖浏览器，使其跨平台能力极强

## 14.vue3如何进行模板编译

1. vue使用其解析器将html模板解析为AST抽象语法树
2. 接着会对AST进行优化，核心目标是找出树中的静态节点，如果一个节点不依赖于任何动态数据，那么这个节点会被提升到渲染函数外部，仅在组件首次渲染时创建其对应的vnode，后续重新执行render函数时不再重复创建。同时还会为动态节点添加patch flag(更新类型标记)，为后续的diff算法做优化。
3. 会根据优化后的AST生成渲染函数render，该函数执行后的返回值是一个虚拟dom树，用于后续diff算法。

## 15.vue3的diff算法的过程是怎么样的？相比vue2有什么优化？

1. diff算法过程：

   - 根节点比较：如果新旧节点类型不同，直接替换整个节点，如果类型相同，则比较其属性，新节点没有的属性进行删除，变更的属性进行更新
   - 子节点比较：在子节点比较的过程中，会根据子节点的类型选择不同的比较方法
     - 如果子节点是文本，则直接替换文本内容
     - 如果子节点是数组，则会通过双端对比加LIS算法进行比较
   - 双端对比：
     - 进行头头，尾尾，头尾，尾头比较
     - 如果头头匹配，就将新旧头指针向右移动一位
     - 如果尾尾匹配，就将新旧尾指针向左移动一位
     - 如果头尾或者尾头匹配，就将旧尾节点移到新节点头指针所在的位置并更新指针位置
   - 注意：如果头头和尾尾同时匹配，会触发中间区域比对：
     - 两对新旧指针之间的部分会被看做中间区域
     - vue会将新中间区域的节点映射到其索引(因为Map的查找效率为O(1))
     - 遍历旧中间区域中的节点，如果在Map里面找不到，说明被删除，能找到，说明可复用
   - 中间区域比对完成后会进行最长递增子序列算法，找到新旧节点中最长的相对位置没有发生变化的节点，其他的节点需要进行移动或创建
2. 相比与vue2的优化：

   - 静态提升：在编译阶段，vue会对静态节点进行标记，这些节点会被提升到渲染函数外部，仅在组件初次渲染时创建，后续diff算法的过程中跳过这些节点的比对
   - 动态节点标记：同样是在编译阶段，vue会对动态节点进行标记，这些标记代表了这些节点的更新类型
   - 区块树打平：一个具有稳定结构的块称为一个区块(没有v-if等结构性指令)，对区块的编译结果不包含静态节点，这样在比对虚拟dom的时候就可以减少很多不必要的比较

## 16.vue 和 react 虚拟dom异同

## 17.Vue中可以写jsx吗？*2

可以，安个插件就能用，"@vue/babel-plugin-jsx"

## 18.Vue的生命周期

1. beforeCreate: 组件刚被初始化，但所有数据并没有初始化-----------------------|
   |---setup()
2. created: 所有的数据已经初始化完毕，包括响应式数据，计算属性，方法，侦听器等---|
3. beforeMount: 模板已经编译，确定了要渲染哪些dom，但并未渲染----------------------onBeforeMount
4. mounted：组件实例被挂载到了dom上，此时可以操作和访问dom-------------------------onMounted
5. beforeUpdate: 数据已经更新，dom尚未更新---------------------------------------onBeforeUpdate
6. updated: dom中的数据也已同步更新完毕，此时可以访问和操作最新的dom----------------onUpdated
7. beforeDestory: 组件实例销毁之前，此时可以清理一些计时器，侦听器等----------------onBeforeUnmount
8. destoried: 组件实例销毁完成---------------------------------------------------onUnmounted

## 19.vue里的key

1. 当作用在v-for的列表渲染中时，key是作为一个唯一标识，供vue的diff算法清楚的知道每一个节点的身份。当列表中节点的顺序发生变化时，vue可以根据key来辨别哪些元素被增加，删除和修改。如果没有key，vue就会根据元素的位置来进行判断，可能导致不必要的dom操作，触发不必要的重排和重绘，浪费性能
2. 当key作用在一个正常元素中时，可以用来强制更新元素。当我们改变一个元素的key值时，vue会认为这是一个全新的元素，那么就会销毁原来的元素并创建一个新的元素。

## 20.vue组件通信

1. props搭配emit
2. provide配合inject
3. pinia
4. vuex
5. 全局事件总线(vue3中是emit库，其实就是一个发布订阅)

## 21.ref reactive

1. ref在大多数情况都比reactive要好，原因如下：
   - reactive无法直接处理基本数据类型，比如number，string，boolean，因为Proxy只能代理一个引用数据类型
   - reactive声明的对象在解构时，解构出来的本地变量会失去响应性
   - 当我们替换整个reactive声明的对象时，新对象同样会失去响应性，因为把Proxy代理的对象换走了
2. 不过当对象的结构非常复杂，我们不想用.value访问对象的属性的时候，就可以用reactive

## 22.组合式 api 的优点是什么

1. 按逻辑组织代码，相同逻辑的代码放在同一个区域，可维护性和可读性更强
2. 可以自定义组合式函数，代码的复用性更强
3. Composition API比Options API的ts支持更好

## 23.v-if和v-show的区别？*2

1. v-if的条件为true时，元素才会被渲染，否则不会渲染元素
2. v-show是通过改变元素的display来控制元素的显示或隐藏

## 25.V-model实际上是什么？

实际上是@update:modelValue 和 :modelvalue的语法糖

## 26.vue 事件处理v-on的原理

## 27.react vue在技术层面的区别、核心区别

## 28.react、vue跨层级通信的区别

# 计网

## 1.websocket是什么，和http有什么区别，建立一个连接需要几步？在过程中浏览器会发送哪些请求，如何变为ws连接？心跳机制和断线重连是怎么实现的？*2

1. Websocket是一个建立在TCP协议之上的全双工通信协议
2. 与http的区别：
   - 长连接，除非某一方主动断开连接，否则不会断开连接
   - 全双工双向通信，服务端可主动向客户端发送数据，而不是请求-响应的方式
   - 头部开销比http小，http每次请求响应都需要携带完整的头部
3. 建立一个连接所需的步骤：
   - 第一步：发送一个http请求，头部包含Connection：upgrade，Upgrade：Websocket，Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==(是一个随机生成的Base64编码的秘钥，用于验证服务器是否真正理解Websocket协议)
   - 第二步：服务端返回状态码101 Switching Protocol，表示同意协议升级，还会返回一个Sec-WebSocket-Accept，浏览器会验证这个值是否正确
   - 第三步：如果Sec-Websocket-Accept值验证为正确，则建立起全双工TCP长连接，双方可随时主动发送数据
4. 心跳检测：
   - 当成功连接Websocket之后，客户端定时向服务端发送一个轻量的消息比如"ping"
   - 服务端在接收到这个消息后，立马向客户端返回一个"pong"
   - 如果客户端能成功收到消息，证明连接正常
5. 断线重连：
   - 当客户端在一定时间内没有收到服务端返回的"pong"后，可以判定为连接失效了
   - 此时等待一段时间后重新发起Websocket连接请求

## 2.cpu和gpu的区别

## 3.对比Websocket，SSE，长轮询，短轮询 *5

| 指标       | websocket    | SSE        | 长轮询        | 短轮询        |
| ---------- | ------------ | ---------- | ------------- | ------------- |
| 通信方向   | 全双工双向   | 服务器单向 | 请求-响应单向 | 请求-响应单向 |
| 协议       | ws           | http       | http          | http          |
| 延迟       | 低           | 低         | 较低          | 高            |
| 服务器开销 | 低           | 低         | 较低          | 高            |
| 客户端开销 | 低           | 低         | 较低          | 高            |
| 数据格式   | 二进制或文本 | 文本       | 任意          | 任意          |

## 4.http 1.0 ,http 1.1，http2，http3的区别，队头阻塞在各个阶段的问题和解决方案 *3

1. http1.0:

   - TCP短连接，每当发送一个请求的时候都需要重新建立TCP连接，非常耗费性能
   - 存在队头阻塞的问题：由于请求是排队一个一个发送的，那么也就意味着，当前一个请求没有被服务器正常处理之前，后面的请求是无法被处理的
2. http1.1:

   - 引入了Connection：KeepAlive，使得TCP可以实现长连接，浏览器一般会控制在6个TCP长连接来并发发送请求
   - 引入了管道传输机制，这使得一个请求不必再等待服务器处理完前面的请求之后才可以发送到服务器
   - 虽然解决了请求的队头阻塞问题，但是仍然存在响应的队头阻塞问题，因为服务器一次性只能处理一个请求，发送到服务器的请求都得等前面的请求响应了之后才能被处理
3. http2.0:

   - 引入了https
   - 对http头部进行了压缩，采用的是HPACK算法，由静态表编码，动态表编码，哈夫曼编码组成，客户端和服务端会共同维护一个字典：

     - 静态表编码：http2.0会将61个常用的http头部存储在一个静态表中，这个静态表的key是索引，value是头部及其值，发送请求时，不再像http1.1那样每次都发送完整的头部，而是先在静态表中查找是否有该头部，有的话用其索引代替完整头部进行发送。
     - 动态表编码：当出现完全相同的重复请求时，客户端和服务端会各自在其维护的表中添加这些重复了的头部，索引从62开始，因此想要触发动态表编码，必须是在同一个tcp连接上面出现完全相同的重复请求，哪怕每次请求只有微小的变化，也不会将头部添加到表中
     - 因此发送的http头部应该是由字典中的索引或完整头部字符串，加上使用哈夫曼编码对头部属性值转换成的二进制数据组成的
   - 二进制帧：http2.0传输的请求响应数据不再是文本类型，而是变成了二进制数据，并且是以帧为单位进行传输：

     - 帧的结构分为：帧长度，帧类型，标志位，Stream ID，帧数据，其中比较重要的是标志位和Stream ID，http2.0中对请求设置优先级控制的就是标志位的值，而Stream ID是用于流式传输中对于同一个流中数据的拼接，帧数据就是用HPACK算法处理过的头部和包体数据
   - 并发传输：http2.0通过流式传输的方式实现了并发传输，解决了队头阻塞问题：

     - 在同一个TCP连接中可以同时存在多个Stream，每一个Stream对应一个请求响应的逻辑通道，里面负责传输Message，一个Message就对应了一个请求或响应，Message会被拆分成多个Frame在Stream里面传输，Frame里面装的就是报文
     - 客户端和服务端均可以通过Stream传输frame，但是所有客户端发送的frame的Stream ID都是奇数，服务端发送的都是偶数
     - 帧是可以乱序发送的，客户端或服务端会根据StreamID来对数据进行拼接
     - 但由于多个Stream需要严格按照顺序处理，并且Stream之间存在依赖关系，因此TCP层需要收到完整的数据包后才会进行处理，因此当出现丢包的情况时，即使后面的数据已经组装完整了，也会由于前面的数据不完整而在TCP层面发生阻塞
   - 服务端主动推送数据：比如当客户端请求一个html的时候，服务端可以顺带把css数据也一并推送到客户端
4. http3.0：

   - 基于UDP协议而不是TCP协议
   - 在UDP协议的应用层开发了QUIC协议，使不可靠的UDP协议变得更加可靠，QUIC协议的特点如下：
     - 彻底解决了队头阻塞，因为UDP中的各个Stream之间没有依赖关系，数据传输可以是无序的，当某个流中的数据丢失时，不会影响其他流
     - 建立连接的速度更快，因为省略了TLS握手阶段，直接使用了QUIC内部的TLS，后续如果连接断开，还可以通过数据包与QUIC握手信息一起发送直接进行重连
   - http3的头部更小，只有帧长度和帧类型，不再需要定义Stream，因为直接使用了QUIC里面的Stream，并且静态表中的头部数据从61项变成了91项

## 5.TCP vs UDP *2

1. TCP是面向连接协议，在传输数据之前需要建立连接，UDP是无连接协议，不需要连接就可以直接发送数据
2. TCP是进行一对一，点对点的服务，而UDP可以进行一对一，一对多，多对多的服务
3. TCP是进行可靠数据传输，保证了数据的完整性和顺序不变，而UDP是尽量保证数据完整，可能出现部分数据丢失和乱序
4. TCP有拥塞控制和流量控制机制，保证数据安全，UDP没有，无法控制传输速率
5. TCP是进行流式传输，UDP是一个包一个包的传输
6. TCP头部开销比较大，UDP头部开销比较小

## 6.csrf xss 防御措施 *5

1. CSRF叫做跨站请求伪造，原理是利用浏览器自动携带cookie的机制绕过身份验证，当用户登录可信网站之后，会利用用户的权证信息发起一些非法请求
2. XSS叫跨站脚本攻击，通过诱导用户点击恶意链接，盗取用户的敏感信息或更改页面dom，有三种类型的XSS：
   - 反射型XSS：通过改变URL中的查询参数，在用户点击恶意链接后，前端直接使用后端返回的未转义的数据导致查询参数中的恶意脚本在客户端执行
   - 存储型XSS：通过向数据库中存储一些未转义的恶意脚本，当用户浏览器解析到该内容时，恶意脚本在用户浏览器中执行
   - DOM型XSS：类似反射型，但反射型是利用了后端的漏洞，DOM型是纯前端漏洞，前端直接使用查询参数中的数据之后，通过在链接中的查询参数添加恶意脚本，导致恶意脚本直接在用户浏览器中执行，服务器完全不知情。
3. 防御措施：
   - CSRF：
     - 在后端实现一个CSRF token，当用户访问敏感内容时，无感的从后端获取一个随机的token，在执行非幂等操作的时候顺带把这个临时的随机token一并发送，用于后端验证
     - 设置Cookie的SameSite=strict，完全禁止第三方Cookie，禁止浏览器跨域携带cookie
     - 验证origin或者referer是否合法
   - XSS：
     - 在前后端对用户输入的内容进行转义
     - 设置CSP请求头(Content-Security-Policy)
     - 设置HttpOnly Cookie，禁止js脚本访问Cookie

## 7.加密方式了解哪些，介绍一下对称加密，非对称加密

1. 对称加密：接收方和发送方双方事先生成好一个秘钥，后续发送方使用此秘钥对内容进行加密，接收方使用此秘钥对内容进行解密
2. 非对称加密：接收方需要准备好一个私钥和对应的公钥，公钥会被接收方分发给发送方，后续发送方使用公钥加密内容，接收方使用私钥解密，保证了数据不会被代发
3. 哈希函数：客户端在发送内容之前会对内容计算出哈希，然后使用公钥对该哈希值进行加密，将加密后的哈希值和内容一起发送出去，服务端使用私钥对加密的哈希值进行解密，并同样对内容计算哈希，如果解密后的哈希值与计算出的哈希值一致，证明内容没有被篡改

## 8.了解CDN吗？如何更新CDN中的内容？

1. 定义：CDN是部署在全球的边缘节点服务器，将一些资源缓存在这些服务器中，当前端在请求资源时，DNS会将请求重定向到最近的，负载最轻边缘节点服务器，加速资源的获取
   - 如果命中缓存，则直接使用缓存
   - 如果没有命中缓存，则从源服务器，也就是自己的服务器中拉取资源，并在CDN中进行缓存，方便后续的资源获取

## 9.Cookie，Local storage，session storage对比 *2

| 区别                       | Cookie         | localstorage           | sessionstorage               |
| -------------------------- | -------------- | ---------------------- | ---------------------------- |
| 存储大小                   | 约4kb          | 约5M                   | 约5M                         |
| 是否会随着http请求自动发送 | 是             | 否                     | 否                           |
| 过期时间                   | 手动设置       | 永不过期，除非手动删除 | 永不过期，除非关闭当前标签页 |
| 谁能访问                   | 任何同源窗口   | 任何同源窗口           | 当前标签页                   |
| 存储位置                   | 浏览器和服务器 | 浏览器                 | 浏览器                       |

## 10.如何实现跨域？ *11

1. 配置CORS：添加响应头Access-Control-Allow-Origin/Header/Methods，允许特定的源，头部，方法访问
2. 利用JSONP script标签天然允许跨域的机制进行跨域，但只支持GET请求
3. 开发环境可以通过配置Proxy的server里面的origin支持跨域
4. 利用ws协议天然支持跨域的特性

## 11.强缓存+协商缓存 *10

1. 强缓存：指的是获取到浏览器返回的资源后，直接将其存储在本地，后续直接使用本地资源，不向浏览器发送请求。强缓存涉及两个响应头：
   - Expires：设置绝对过期时间，一般不设置这个，因为可能受到本地时间的影响
   - Cache Control: 设置相对过期时间和其他配置，优先级高于Expires
2. 协商缓存：指的是当强缓存过期之后，携带缓存头向服务器发送请求比对资源，如果资源未修改，则返回304和新的缓存头，继续使用本地缓存，如果修改过，返回新的资源和200。涉及两组头部：
   - If-Modified-Since 和 Last-Modified，Last-Modified无法识别两种情况：一个是资源修改时间变了但内容未修改，一个是一秒内资源内容发生多次变动，他最多精确到秒，所以无法处理毫秒级
   - If-None-Match 和 Etag
3. 缓存流程如下：第一次请求时，如果返回的头部中有Last-Modified或者Etag，浏览器会将其存储起来，后续请求时，如果前面设置过强缓存，则检查缓存是否过期，如果没有过期，则直接使用本地资源，如果过期了并且未完全禁用缓存，则触发协商缓存。浏览器会携带缓存头，也就是Last-Modified或者Etag，如果两者同时出现，Etag优先级更高，并且他的精确度也更高，因为他表示的是资源唯一标识符，然后向服务器比对资源修改时间或资源唯一标识符，如果资源未修改，则返回304和新的缓存头，继续使用本地缓存，如果修改过，返回新的资源和200。

## 12.HTTPS和HTTP的区别 *2

1. http是明文传输，https是加密传输
2. https比http多了一个TLS连接
3. 默认端口号不一样，http是80，https是443
4. https有CA机构颁发的数字证书，http没有

## 13.HTTPS如何防止数据被篡改的 *2

1. 混合加密：

   - 非对称加密：在TLS握手阶段使用非对称加密交换会话秘钥，保证了数据的安全，但速度较慢
   - 对称加密：后续使用会话秘钥对内容进行加解密，速度较快，因此混合加密兼顾了数据的安全和传输速度
2. 哈希函数+数字签名：
   见第七题的第三个回答
3. 数字证书：由于私钥也可能被中间人伪造，所以引入了数字证书机制

   - 服务端会将其私钥对应的公钥放到CA机构，CA机构会使用CA的私钥对服务器公钥进行加密，并生成数字证书返回给服务器
   - 客户端请求数据的时候，服务器会将数字证书一起返回回去
   - 客户端会利用事先放置到操作系统或者浏览器中的CA公钥对数字证书中的加密私钥进行解密
   - 如果能正常解密，就利用解密得到的服务器公钥对传输的数据进行加密
   - 服务器用私钥解密数据，保证数据的安全

## 14.说说 HTTP 请求的结构

1. 请求行：包含了请求方法，请求目标(包括请求路径和查询参数)和HTTP版本
2. 请求头：HTTP头部
3. 请求体：请求要发送给服务端的具体数据

## 15.HTTPS请求从用户发起到到接收数据的整个过程

直接回答TCP三次握手 + TLS四次握手 + https是如何保证数据安全

## 16.什么叫做HTTP的流式响应

http流式响应是在http2.0中的改进，在http2.0中，一个TCP连接包含了多个流，每个流里面都包含着很多Message，这些Message对应着客户端的请求和响应，每个Message里面包含了一个和多个Frame，Frame里面就是http报文。流式响应使得数据在传输的过程中可以是乱序的，因为TCP接受数据时会根据每个数据帧的头部帧里面的流ID对分散的数据进行拼接，当一个请求报文组装完整了之后，会拆分成一个或者多个Frame进行响应数据的返回。流式响应也从http层面解决了http1.1中由于一个连接只能同时传输一个请求导致的队头阻塞的问题。

## 17.http状态码 *3

1. 1xx：

   - 101：表示协议切换成功
2. 2xx：

   - 200：请求在服务端被正常处理并成功响应
   - 201：请求成功，并且在服务端创建了新资源
   - 202：请求已经被接受，但还未处理完成，可能会被处理也可能不会被处理
   - 204：请求成功，但不需要返回任何资源
3. 3xx：

   - 301：资源永久重定向，页面的权重和SEO永久迁移到新地址，并且浏览器会缓存新地址，下一次再访问旧地址时会直接跳转到新地址
   - 302：资源临时重定向，页面的权重和SEO仍在原页面，每次重定向都要向服务器发送请求进行确认，浏览器不会缓存
   - 304：协商缓存
4. 4xx：

   - 400：请求语法有误，服务器不认识
   - 401：请求没有携带权证
   - 403：请求被拒绝
   - 404：请求的资源在服务端找不到
5. 5xx：

   - 500：服务器内部错误
   - 501：服务器尚未实现某种功能
   - 503：服务器繁忙或者是正在维护，服务不可用

## 18.浏览器的同源策略都限制了什么？是不是所有类型的请求都拦 *4

1. 同源策略限制了浏览器跨源进行通信，同源指的是协议，域名，端口均相同，任意一个不同都视为跨源
2. 不是所有请求都拦，简单请求不会拦截，复杂请求会拦截

## 19.简单请求和复杂请求分别是什么？

1. 简单请求需要符合以下条件：
   - 请求的方法属于get，post，head之一
   - 请求头部只有安全的头部，比如Accept,Accept-Language,Content-Language,Content-type。
   - Content-type为text/plain, multipart/form-data,application/x-www-form-urlencoded之一
   - 没有在请求中使用ReadableStream对象
2. 不符合简单请求条件的均为复杂请求

## 20.什么是OPTIONS预检请求？*3

1. 当一个请求为复杂请求时，浏览器会预先给服务器发送一个OPTIONS预检请求，来问问服务器是否允许这个请求
2. OPTIONS请求包含：
   - Access-Control-Request-Headers/Method: 复杂请求中涉及的请求方法和请求头部
   - Origin：复杂请求的请求源
3. 服务器会给OPTIONS请求返回服务器的Access-Control-Allow-Headers/Method/Origin,如果服务器允许跨域，则后续再发送真实的请求

## 21.TCP 的重传机制、拥塞控制有了解吗，介绍一下TCP的慢启动？

## 22.滑动窗口有什么作用？

## 23.http的get和post区别 *2

1. 从语义上来看，get是拿数据，post是上传数据
2. get是幂等的，不会对数据进行修改，post是非幂等的，会修改服务器中的数据
3. get的参数一般放在url中，post的参数放在请求体

## 25.浏览器为什么要有两种缓存

## 26.如果想要一直用强缓存不强求服务器，又想在资源更新时及时接收，应该怎么设计

文件名配哈希，在资源变的时候哈希也变，重新缓存

## 27.能讲一下 TCP 吗？

略，综合上面所有TCP相关题目

## 28.http2的服务端推送是干什么的？

略，参上

## 29.cache control有哪些常见字段 *2

1. max-age: 用于设置相对过期时间，单位是秒
2. no-catch: 禁用强缓存，触发协商缓存
3. no-store: 完全禁用缓存
4. public: 允许被任何(客户端，代理服务器)缓存
5. private: 允许被一个客户端缓存

## 31.跨域怎么携带cookie

跨域携带Cookie需要客户端和服务端共同配合

1. 在客户端中，如果使用的是axios，需要在发送请求的时候添加一个option对象，包含withCredentials: true
2. 在服务端中，需要配置跨域的头部：Access-Control-Allow-Credentials: true
3. 在设置Cookie的时候，需要把Cookie的SameSite设为none,否则会禁止跨域携带

## 32.跨域是在哪里拦的？请求到底有没有发出去

在浏览器拦的，第二问参考简单请求和复杂请求以及预检请求

## 33.三次握手时各自发送的报文是什么？*2

1. 第一次握手：客户端初始化自身序列号，将序列号放到TCP头部的序列号位置中，将SYN标志位变为1，向服务端发起建立连接请求，发送请求后自身状态变为SYN-SEND
2. 第二次握手：服务端收到建立连接请求后，初始化自身序列号，将其置入TCP头部的序列号位置中，然后将客户端第一次初始化的序列号+1，放到TCP头部的确认应答号位置中，再将TCP头部SYN和ACK标志位变为1后，向客户端返回一个应答，服务端状态变为SYN-RCVD
3. 第三次握手：客户端收到服务端应答后，将应答中的序列号取出并+1，作为这次请求的应答号，同时将标志位ACK变为1，这次的请求可以携带客户端到服务端的数据，发送后，客户端状态变为ESTABLISHED，服务端收到后也变为ESTABLISHED

## 34.四次挥手时各自发送的报文是什么？*2

1. 客户端将TCP头部FIN标志位变为1，向服务端发起断开连接请求，之后客户端状态变为FIN_WAIT1
2. 服务端收到客户端断开连接请求之后，向客户端返回一个ACK应答，状态变为CLOSE_WAIT，等待服务器发送完数据之后，会再向客户端发送一个FIN报文
3. 客户端收到服务端的ACK应答后，状态变为FIN_WAIT2，客户端收到这个FIN报文后，会向服务端返回一个ACK应答，然后自身状态变为TIME_WAIT，在经过一段时间后，客户端状态变为CLOSE，自动关闭连接
4. 服务端在收到客户端的ACK应答后，状态变为CLOSE，服务端连接关闭

## 35.TCP 为什么是三次握手

1. 保证双方都有发送和接收数据的能力
2. 避免历史连接：如果是两次握手，那么在服务端收到客户端的SYN报文的时候就已经建立了连接，如果在第一次握手的时候发生了网络阻塞，那么在恢复网络时，历史连接的序列号仍然会被发送到服务端，这时服务端在接收到旧序列号时也会建立连接，发送数据，等到新的连接真正发送到服务端时，又要重新建立连接发送数据，这就造成了资源浪费和重复发送。如果是三次握手，那么客户端就可以通过服务端第二次握手时传来的确认应答号判断是否应该断开连接，再向服务端发送一个应答。如果符合客户端期待的序列号，则正常建立连接，如果不符合，则将RST标志位设为1，触发重新连接。
3. 同步双方序列号：根据自身随机生成的序列号和对方返回的确认应答号进行序列号的同步，序列号的同步有助于：

- 接收方可以根据序列号去除重复的数据
- 可以根据数据包的序列号按序接收
- 可以标识发出去的数据包有哪些是已经被对方收到的
- 这一步其实可以通过四次握手实现，只不过把服务端的SYN和ACK优化后合并成了一步。

## 36.TCP断开连接为什么需要4次挥手

因为当客户端申请断开连接时，客户端就不会再发送数据了，而服务端不一定，他在接收到客户端的断开连接请求之后，可能还有数据没有发送完，所以一般是先发送一个ACK应答，然后将所有数据发送完成之后，再发送FIN报文，标志着数据已经发送完毕，ACK和FIN一般是分开发送，所以变成了4次挥手

## 37.TLS四次握手分别发送了什么报文

1. Client Hello：客户端向服务端发起建立加密通信请求，并发送以下数据
   - 客户端支持的TLS版本，如TLS1.2
   - Client Random：一个客户端生成的随机数，后续用于生成会话秘钥
   - 客户端支持的密码套件列表，比如RSA
2. Server Hello：服务端接收到客户端的请求后，向客户端发送一个响应，并包含以下数据：
   - 确定的TLS版本，如果服务端不支持客户端想要使用的TLS版本，则断开加密通信连接
   - Server Random：一个服务端生成的随机数，后续用于生成会话秘钥
   - 确定使用的密码套件列表
   - CA机构颁发的数字证书
3. Client Ack：当客户端收到服务端的响应之后，首先会使用预先放置在浏览器或者是操作系统中的CA公钥对数字证书进行验证，如果数字证书真实可信，则取出其中包含的服务端公钥，然后向服务端发送如下数据：
   - pre-master key：生成一个新的随机数作为预主密钥，并且该随机数会被服务端公钥加密，然后通过三个随机数生成会话秘钥
   - 加密通信算法改变通知，表示随后的通信数据都会用会话秘钥进行加密
   - 客户端握手结束通知，标志着客户端的握手阶段已经完成，随后会对之前通信内容进行一个摘要，发送给服务端，供服务端进行校验
4. Server Ack：当服务端收到预主密钥之后，生成会话秘钥，然后向客户端返回如下数据：
   - 加密通信算法改变通知，表示后续通信数据均用会话秘钥进行加解密
   - 服务端握手结束通知，表示服务端的握手阶段已经结束，随后会对前面的通信内容生成一个摘要，供客户端进行校验

## 38.JSP的原理

## 39.计网七层模型，TCP，IP在哪一层

## 40.IP协议有什么用

## 41.子网掩码是什么意思

## 42.ipv4 ipv6区别，ipv6中有子网掩码吗，ipv6前缀的作用

## 43.ipv6是多少位的

## 44.操作系统死锁概念，四个必要条件

## 45.进程和线程区别

## 46.进程之间通信方式

## 47.半双工含义

# 浏览器

## 1.ssr和csr区别以及使用场景 hydration怎么处理优化 水合失败会怎样 ssr渲染速度有可能比csr更慢吗 ssr渲染的html是怎么变成动态的 * 3

1. ssr和csr区别：

   - 首屏加载速度方面，ssr更快，因为从服务器拿到的是完整的html资源，可以直接显示在浏览器上
   - 服务器压力方面，ssr更大，因为每次切换页面都会从服务器重新获取html资源
   - seo方面，ssr更好，因为浏览器可以直接爬取完整的html
   - ssr是在服务器中生成html，csr是在浏览器中生成html
2. 使用场景：

- ssr：
  - 对首屏加载速度有需求，对seo需求高的内容导向性网站
  - 社交媒体这种需要快速展示内容的应用
- csr：
  - 强交互型网站，如果网站有复杂的交互或者需要频繁跳转页面，适合用csr
  - 页面有复杂的动画或者状态管理

3. 水合过程：

   - 从服务器中获取完整html和相关的js代码
   - html被浏览器解析并渲染到页面中，后台下载js代码
   - 下载完成后，执行js代码，vue或者react重新执行html代码，但不创建新的dom，只是将代码和框架中的组件联系起来，建立响应式系统和状态管理
4. 水合失败的后果：

   - 浏览器会丢弃服务端返回的html，重新在浏览器端渲染页面，违背了ssr的初衷，导致了更慢的首屏加载速度
   - 用户看到的页面会闪烁或者内容突变
   - 保存在初始html中的一些状态可能会在重新渲染后丢失
5. ssr渲染速度有可能比csr更慢，因为虽然首屏会更快，但可能由于服务器压力大导致html返回时间过长，或者是水合过程较为复杂，执行大量的js代码阻塞主线程UI导致页面无法交互，使得用户的整体体验比csr更慢

## 2.哪些情况可能会触发重渲染 *3

1. 初次渲染页面
2. DOM节点进行了新增，删除，或结构性的调整
3. 浏览器视口大小变化
4. 元素的大小，位置等属性改变
5. 元素的样式发生了变化
6. 优化建议：

   - 尽量一次性修改多个dom节点而不是逐个修改
   - 尽量一次性修改完css属性而不是逐条修改，使用class而不是style
   - 避免使用table布局
   - 动画使用transform和opacity，这两个属性更改只会重新合成
   - 将要修改的元素的display先设为none，等修改完后再复原

## 3.回流和重绘的流程是什么 *2

1. 重排指的是，当元素的几何属性发生变化而导致页面的结构发生变化时，浏览器需要重新计算该元素以及受影响元素的几何信息和布局
2. 重绘指的是，当元素的外观发生变化，但是并不影响页面结构时，浏览器会重新绘制该元素的样式
3. 重排一定会触发重绘，重绘不一定会触发重排

## 4.从输入URL到页面渲染发生了什么？*11

关于这个问题我其实更像配合浏览器环境的Performance对象来谈一谈

1. 输入URL之后，浏览器会解析地址栏中的内容，如果是url则直接跳转，如果是关键词，浏览器会用其默认的搜索引擎构建一个新的url进行跳转和搜索
   此时会触发navigationStart, redirectStart和End进行导航和重定向
2. 第二步是进行DNS解析，会触发Performance里面的domainLookedUpStart/End
   这一步首先会查找是否有缓存，缓存的查找顺序依次为浏览器缓存->操作系统缓存->路由器缓存->ISP DNS服务器缓存
   如果没有缓存，再去递归查找域名，本地的DNS服务器会向根域名服务器发起查询，然后是顶级域名服务器，再是权威域名服务器，最后找到对应的ip地址，返回给本地DNS服务器
3. 进行TCP三次握手建立连接，如果是HTTPS，还会进行TLS握手，会触发Performance中的connentStart->secureConnectionStart(如有TLS的话)->connectEnd
4. 发起http请求，服务器收到客户端请求后，对请求进行处理后返回相应的响应数据和状态码，触发Performance中的requestStart/End,responseStart/End
5. 浏览器渲染引擎开始工作，首先将html解析为DOM树，然后将CSS解析为CSSOM树，将二者合并为渲染树之后，触发重绘和重排，得到各个节点的几何信息和绝对像素，将这些数据发送给GPU合成图层显示
6. 执行JS代码，异步加载外部资源，触发domContentLoaded和load事件后，页面可交互

## 5.浏览器一帧可以完成哪些操作
1. 执行用户的一些事件，比如click，input，change等
2. 执行定时器中的任务
3. 执行requestAnimationFrame中的回调
4. 如果页面有变化，进行dom的重排重绘
5. 将重排重绘得到的几何信息和绝对像素发送给gpu合成图层显示
6. 执行requestIdleCallback中的任务

## 6.浏览器一帧有多久，说了60FPS问转换成时间是多久

16.7ms，60帧就是1秒

## 7.进程和线程的区别 *2
1. 进程指的是一个正在运行的程序，是资源分配和拥有的基本单位
2. 线程是CPU调度的最小单元，是进程中的一部分
3. 进程之间资源是独立的，而线程是直接共享进程中的资源
4. 一个进程崩溃不会影响其他的进程，而一个线程崩溃会导致其他线程以及其所在的进程崩溃
5. 进程比线程的资源开销更大，因为需要为其分配独立的堆栈空间和资源，而线程只占用极小的栈空间

## 8.事件冒泡 事件捕获 事件委托 *4
浏览器的事件流分为三个阶段：捕获阶段，目标阶段和冒泡阶段，当我们对一个元素进行操作时，会先进行事件捕获，也就是从html元素的外层向内层进行事件的传递，一直传递到目标元素，这个过程中，所有设置了捕获事件处理器的元素都会被触发。接着，事件处理器在事件的目标元素上执行，执行完毕后，事件从目标元素向外层元素冒泡，触发途中所有设置了冒泡事件处理器的元素，完成冒泡阶段

## 9.requestAnimationFrame和setInterval的区别？

requestAnimationFrame是在浏览器下一次绘制之前执行传入的回调函数，而setInterval是一个定时器，定时执行回调函数，会返回该定时器ID，只要不销毁该定时器，就会一直定时执行回调

## 10.浏览器渲染过程详细说一下 *2

# 工程化

## 1.vite带来了哪些优化 -> webpack和vite区别 * 5

## 2.pnpm和npm的区别

1. 依赖管理方式不同：

- npm：npm在3.0版本以前，node_modules是嵌套结构，依赖层级非常深，容易导致路径过长和重复安装的问题。在3.0版本以后，npm将node_modules进行了扁平化处理，但是导致了新的问题：
  - 幽灵依赖：项目可以使用依赖的依赖。比如说一个依赖使用了loadsh，假设我们的package.json文件中并没有直接依赖lodash，但是此时在代码中导入lodash是直接可以工作的。这非常危险，因为当某天那个依赖不再依赖lodash之后，项目会直接出错。
  - 依赖不确定性：同样的package.json文件，在不同的时机安装，得到的node_modules可能不同，因为提升的包可能不同。这就会导致在不同的机器上运行效果可能不一致的问题。
- pnpm：
  - pnpm采用了硬链接的方式，所有下载过的包都会被存到pnpm的全局store中，意味着同一个版本的包只会在电脑上存在一份
  - 当其他项目在引入依赖时，pnpm会从全局store硬链接这些依赖到node_modules/.pnpm中，不会占用额外空间
  - 然后pnpm会在node_modules目录下创建符号链接，指向.pnpm目录下的对应目录，然后nodejs就可以正常访问引入的依赖了

2. 性能和磁盘空间占用：

- 由于npm会重复的安装依赖，导致一个依赖可能在电脑上存在很多份，会浪费存储空间，而pnpm对于同一个依赖只会存储一份，节省了大量的重复存储
- 由于npm是对依赖进行文件复制，每次安装依赖时都会进行文件复制操作，速度很慢，而pnpm是直接通过硬链接寻找依赖地址，并不会直接操作文件，所以下载速度要更快

## 3.Git常用命令有哪些？rebase和merge，stash，cherry-pick的作用和区别是什么？*3

## 4.了解Vite速度快的原因和热更新（HMR）的原理吗？*3

- 将开发环境和生产环境分离：
  - 开发环境下追求速度和开发体验，直接启动一个vite服务器，基于原生ESM，无需打包代码。当浏览器请求资源时，vite服务器再按需编译并返回源码
  - 生产环境下追求生产性能和兼容性，使用Rollup打包，进行代码分割，tree shaking等优化
- 按需编译：当我们在浏览器中打开一个html时
  - vite会解析这个html文件，找到其中指向main.js的script标签，然后浏览器会根据其中的import语句发起一连串的http请求
  - 对于第三方依赖，vite会通过依赖预构建进行优化，对于源码，会直接向vite服务请求对应的模块文件
  - 当vite收到模块文件请求之后，会使用esbuild将该文件转为ESM的js代码，然后通过http响应返回给浏览器
  - 整个过程都只会对视口中使用到的模块进行编译，因此可以立即启动，启动速度几乎与项目规模无关
- 热模块更新(HMR):
  - 传统编译工具会对更新的模块以及引入了该模块的相关文件进行重新打包，再通过Websocket传递给浏览器
  - 而vite首先会将该更新模块与引入该模块的链失活，然后通过Websocket向浏览器发送一个更新通知，浏览器收到通知后重新向服务器请求该模块，只需要对一个模块进行操作
- 依赖预构建：
  当我们第一次启动vite服务器时：
  - vite会将未使用ESM的第三方依赖通过esbuild转为ESM，使得浏览器可以正确导入
  - vite会将某个库散列的大部分文件合并成一个或几个文件，防止浏览器进行大量的http请求造成性能问题
  - 被预构建的依赖会被缓存到node_modules/.vite文件夹中，只有当package.json或者锁文件变化时才会重新执行预构建

## 5.什么叫AST，ast在前端工程化的作用有哪些？

1. AST是抽象语法树，他是通过将代码进行词法分析和语法分析而得到一个由节点组成的树形结构

- 词法分析：就是将代码拆分成一个个具有意义的单词，称为令牌
- 语法分析：就是将词法分析得到的令牌根据语言的语法组成一个树形结构，这个树形结构中可以清晰的得到各个节点的嵌套关系和从属关系

2. AST的作用：在将源代码解析为AST之后，我们可以利用各种规则对AST进行检查，转换，优化等操作，然后重新生成为新的代码，作用场景有：

- Vue的模板编译阶段，会先将代码转为AST，找出其中的静态节点并进行静态标记和静态提升之后，输出一个渲染函数
- ESlint会根据配置的代码规则对AST进行节点检查，将不符合规范的代码进行转换
- vite，webpack这种打包工具会遍历AST，找到其中的import或者require语句，构建依赖关系，vite会基于ESM的静态语法，找出没有用到的死代码，在打包过程中将其移出

## 6.tree shaking底层怎么实现的

1. 打包工具会从入口文件开始，将每个模块的代码解析为AST
2. 遍历AST，找出所有的import和export语句，并递归的构建依赖关系图
3. 打包工具会重新从入口文件开始，进行一种标记清除的过程，这个过程主要是对节点进行标记：将入口文件中明确被使用的导入标记为live，然后进入这个被标记为live的文件，重复前面这种标记的过程，直到所有被入口文件直接或间接导入的代码都被标记为live
4. 在后续的打包过程中，就可以安全的根据live标记来清除未使用的死代码

## 7.ESM和CJS的区别，CJS能tree shaking吗 *2

主要是导入和导出的语法区别：

1. ESM的导入使用的是import，并且需要在文件顶层导入，是一个静态的过程；CJS的导入使用的是require函数，可以在后续代码执行的过程中进行导入，是一个动态的过程
2. ESM的导出使用的是export关键字或者export Default进行默认导出，CJS的导出使用的是export.或者export.modules

CJS一般是不能进行tree shaking的，或者说效果不好，因为动态导入的特性使得打包工具难以构建出清晰的依赖图，难以对代码进行是否被使用的分析

## 8.ESM可以动态导入吗

ES2020中对import支持了动态导入，import()返回一个Promise，then中的参数即为导入的模块，可以使用模块中导出的各种方法和属性

## 9.回退提交的命令

## 10.babel作用

1. 将js代码转换为旧版本浏览器可以理解的代码
2. 将jsx转换为普通js代码
3. 通过polyfill插件为旧环境提供缺失的api
4. 可以将代码在不同的模块模式之间转换

## 11.import 与require的区别？

1. import同时支持静态和动态导入，require只能动态导入
2. import的静态导入必须在模块顶部进行导入，动态导入不限制导入位置
3. import导入是在编译时加载，require是运行时加载
4. import导入的模块是对值进行引用，但是是只读的，require是值拷贝

## 12.git pull 和fetch有什么区别

git pull = git fetch + git merge，拉取之后会自动合并

# 性能优化

## 1.怎么去优化减少一个项目的打包体积
代码压缩
代码分割
treeshaking

## 2.前端性能优化做过吗？有哪些策略？*2
### 优化后结果
1. LCP：2.9s（使用vite默认配置进行打包且无nginx配置优化） -> 1.4s（开启nginx的gzip压缩） -> 1.2s（开启CDN加速）
2. FCP: 1.6s -> 1.0s -> 0.7s

### 优化过程
1. 一开始对首屏优化没有了解，直接使用vite的默认配置进行打包，最终会得到巨大的LCP，因为首屏有一个大图片，FCP是1.5s，LCP是3.0s
2. 后来了解到vite在打包过程中默认使用esbuild进行代码压缩，但是通过将terser安装为开发时依赖，在打包时用terser进行更精细的代码压缩，虽然没有使FCP有显著降低，但是LCP减少了0.4s左右，降到了2.6s
3. 虽然打包过程中有了些优化，但是还不够，2.6s的LCP的首屏体验还是很慢，了解到有一个插件叫rollup-plugin-visualizer，在打包后可以进行可视化分析，看到element组件库的包体积很大，于是又进行了分包，把Element组件库在打包过程中分出去了，但是两个指标并没有降低
4. 后面发现在可视化分析中除了gzip压缩还有一个brotli压缩，于是通过询问ai和查看一些视频，得知有一个vite-plugin-compression插件，可以将优化后的js代码以及资源文件进行brotli压缩，于是压缩后又重新上传到服务器，发现还是作用不大。又去问ai怎么回事，才知道是因为本身我首页请求到的资源不大，都是小体积js文件或者css文件，那代码压缩对于首屏优化的效果就不明显，因为本身就已经很小了。
5. 后面我又在nginx中配置了gzip压缩，FCP直接降到0.9s，LCP直接降到1.6s，问了ai才知道，不管是terser还是vite-plugin-compression，相当于都是对源文件进行优化，而线上浏览器在请求资源文件时靠的是nginx进行反向代理，nginx才是真正在优化传输时的资源，所以我在配置了nginx压缩的基础上重新进行了测试，默认配置下分别是1.2s和2.2s，只配置terser时的LCP和FCP分别是1.0s和1.8s，由于只有一个element-plus的包比较大，而且本身已经配置了element的自动按需导入，所以分包对于优化的效果不明显，配置了brotli压缩插件后，LCP和FCP也几乎没有优化，因为terser压缩后的资源文件已经很小了。
6. 极致的LCP和FCP应该在1.2s和0.7s左右，因为我一开始并不是将前端部署在云服务器上，而是部署在github pages上面，github pages默认采用的是使用http2.0进行部署，http2.0对于网络传输已经做了很大的优化比如头部压缩，二进制帧，流式传输等等，而且github pages有cdn加速，所以可以对首屏加载进行进一步优化，这两步应该是后续我的优化措施

### 优化策略
1. 代码压缩：vite进行代码压缩默认使用的是esbuild，但是还可以将terser作为代码压缩的依赖进行配置，esbuild压缩快，不需要额外添加项目依赖，但压缩的程度不是特别高。terser虽然说要额外添加依赖，而且打包速度不如esbuild，但是压缩程度高，质量比esbuild更好。terser主要进行的是压缩js，降低js的解析时间。
2. treeshaking：原先使用的是esbuild进行treeshaking，只能移除consloe语句，debug还有注释，terser可以进行更精细的配置，除了前面三个之外，还可以移除未使用的js代码，未使用的函数，以及无效的代码。
3. 首页图片懒加载：考虑自己封装v-lazy指令和第三方库vue3-lazyload，Elementplus中的el-image组件也支持图片懒加载
4. rollup-plugin-visualizer插件：该插件是将打包结果进行可视化分析，页面可以直观地看到代码treeshaking后的包体积，以及进行gzip和brotli压缩后的代码体积，各个bundle的体积也可以看的非常清楚，方便开发人员进行详细的分析
5. vite-plugin-compression: 这个插件主要是将优化后的资源文件压缩生成gzip文件或者br文件，减小网络传输体积

# 手撕

## 1.手写eventbus的once *3                                                  ✅️

## 2.手写一个usefetch

## 3.手写类似四则运算 *4

## 4.promise.all * 4                                                        ✅️

## 5.嵌套对象扁平化 *2

## 6.手写数组的flat方法 *3                                                   ✅️

## 7.事件循环输出题 *2                                                       ✅️

## 8.手撕三数之和                                                            ✅️

## 9.防抖和节流函数， 应用和原理 *n                                           ✅️

## 10.深拷贝 浅拷贝 *2                                                       ✅️

## 11.数组转树 *3                                                            ✅️

## 12.数组去重都有哪些方法                                                    ✅️

## 13.自适应两栏布局                                                         ✅️

## 14.倒计时组件                                                             ✅️

## 15.手撕快排

## 16.animation简单动画的实现（从中间移动到最左边，并保持在最左边）              ✅️

## 17.实现继承

## 18.实现一个工具类型，返回一个数组中每个元素的类型组成的联合类型

## 19.使用JS实现一个栈，尽可能多的方法

## 20.求二叉树根节点到叶节点数字之和

# 场景题

## 1.如果页面发生卡顿 白屏，如何排查 *3

## 2.如何定义是加载慢还是白屏呢

## 3.一个标题栏，左右可能都有长度不等的东西，怎么保持标题居中

## 4.flex实现，有标题，内容区域，底部区域。内容太长时需要滚动，太短时需要填充，怎么去做（没听懂具体相表达的意思，后来复盘感觉是想听到视口相关

## 5.怎么用css border实现三角形

## 6.设备老旧、ES Module在部分浏览器跑不起来时，如何实现异步实例获取

## 7.lcp和fcp具体含义和优化手段

## 8.发布后遇到线上bug该怎么解决？

# 其他

## 1. 有没有了解过微前端

## 2. 微前端的优势

## 3. 什么是SPA与MPA的区别

## 4. History和hash模式History和hash模式

# React

## 1.React 双缓冲架构

## 2.react列表为什么需要key，没有key会怎么样 * 3

## 3.React 组件通信方式 *2

## 4.React 性能优化手段

## 5.介绍下fiber架构，为什么 Fiber 是异步可中断的 *3

## 6.使用外部库对比使用 Context 有什么优势

## 7.react 使用过的hooks 以及各自作用 useLayoutEffect和useEffect区别及使用 * 6

## 8.状态管理 useContext和zustand使用场景

## 9.受控组件和非受控组件 *2

## 10.父子通信：React父子通信有几种方式？

## 11.深层嵌套问题：深层次的嵌套这个数据传递，有什么解法？

## 12.事件传递：有一些事件需要往下传的情况下，有什么解决方案？

## 13.Class vs Hooks：平时是Class组件还是Hooks？

## 14.Hooks优缺点：说一下Hooks的优缺点

## 15.Hooks对比：用Hooks或者去写业务逻辑和用Class去写，他们有什么优缺点？ *2

## 16.状态管理：页面有很多数据，每一个数据都可能是用useState去创建或者更新，你是怎么去组织它或者管理它？

## 17.React 虚拟 DOM

## 18.useMemo的作用是什么

## 19.React 生命周期 *2

## 20.React的渲染机制

## 21.React的diff算法

## 22.为什么 React Hooks 不能放在分支逻辑（如 if 语句）里

## 23.react18新增的hooks

## 24.useState返回为什么是数组不是对象

## 25.react render执行过程

## 26.React 的高阶组件
