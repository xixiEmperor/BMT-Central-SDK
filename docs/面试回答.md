# 任务队列（Task Queue）STAR 面试回答

代码位置：packages/sdk-core/src/task-queue.ts

---

## S（Situation，场景）
- 业务痛点：
  - 前端/SDK 在高并发上报、批量写库或外部 API 密集调用时，瞬时并发容易造成后端过载、数据库死锁与级联失败；客户端缺乏统一的并发闸门、重试/超时与进度观测机制，问题不可控且难以定位。
- 技术背景与约束：
  - 运行于浏览器事件循环之上（单线程），不依赖额外线程或服务；需要以轻量方式实现“应用层调度治理”，同时兼顾高吞吐与稳定性场景。
- 目标读者：
  - SDK 使用方（业务开发）与平台侧（SRE/后端），期望以最小改造接入统一的任务治理能力。

## T（Task，目标）
- 设计目标：
  - 并发治理：限制并发（maxConcurrent）、节流（requestInterval），避免过载与锁竞争；
  - 可靠性：为每个任务提供超时、取消、重试（退避），并明确失败归档；
  - 可观测：实时进度与统计（完成率、失败数、执行中数、耗时等），便于告警与容量评估；
  - 易集成：对外仅需 Promise 风格任务函数 Task<T>(data?, abortSignal?) 即可接入；
  - 可扩展：提供多场景默认策略（高并发/低并发/数据库），支持运行期 updateConfig。
- 可验证的验收口径（示例）：
  - N=500/1000 任务、并发=10 压测下，服务端 5xx 无显著增幅；客户端无“在途任务持续增长”的积压；
  - 超时任务在 timeout 内失败退出；失败任务在 maxRetries 与退避策略内有序收敛；
  - 回调与统计可驱动观测：percentage、elapsedTime、successRate 可用于阈值报警与容量评估。

## A（Action，行动/方案）
- 并发调度与优先级：
  - 生产者-消费者模型；队列按 priority 降序排序，高优先任务优先出队；
  - processQueue 控制并发闸门（执行中任务数 < maxConcurrent 时才调度），并按 requestInterval 进行轻量节流；
  - 调度循环与执行解耦：队列循环非阻塞执行任务，空闲时自动继续调度。
- 生命周期与控制面：
  - 状态：pending → executing → completed/failed 或 retrying；
  - 控制：start/pause/resume/stop/clear/updateConfig/retryFailedTasks 覆盖运行期运维动作；
  - 停止：stop 触发 AbortController 中断在途任务，防止继续占用资源。
- 可靠性增强：
  - 超时：任务与 timeoutPromise 做 Promise.race，避免“悬挂任务”；
  - 重试：记录重试计数，按 retryDelay × retries 做退避（可扩展为指数退避+jitter），超过 maxRetries 归档 failed；
  - 取消：每个任务持有 AbortController，业务 fn 可响应 signal 实现快速中断与资源清理。
- 可观测性与回调：
  - 回调：onProgress（实时进度）、onTaskComplete（单任务结论）、onQueueComplete（整体收敛）；
  - 统计：total/completed/failed/executing/pending、percentage、elapsedTime、successRate，用于 UI 展示与埋点上报。
- 易用性与复用：
  - 任务抽象：Task<T> = (data?, abortSignal?) => Promise<T>；
  - 预设工厂：createHighConcurrencyTaskQueue / createLowConcurrencyTaskQueue / createDatabaseTaskQueue，降低配置成本。
- 取舍与对比：
  - 不直接用“裸 Promise + setTimeout”：缺乏全局并发闸门与统一重试策略，可观测性不足；
  - 不引入 Web Worker：本方案聚焦调度治理，Worker 带来的序列化/集成成本不划算；
  - 与 RxJS/第三方库对比：本实现学习/集成成本更低，回调与统计契合 SDK 约定且易于按场景裁剪。
- 边界与风险意识：
  - 优先级饥饿：持续高优先任务可能饿死低优先；可引入老化或加权轮询；
  - 幂等性：重试可能引发副作用重复，业务需保证幂等或区分“可重试/不可重试”错误；
  - 积压与背压：持续 inflow 可能堆积；可设置最大队列长度并向上游反馈背压；
  - 超时/取消：业务任务需响应 AbortSignal，否则仍可能耗资源（队列视角已失败）。

## R（Result，结果/价值）
- 将不可控的瞬时并发变为“可控并发阈值 + 调度节奏”，显著降低后端过载与数据库死锁风险；
- 将无序重试变为“有上限且退避的重试”，提升整体成功率并避免二次雪崩；
- 进度与统计让故障可观察、可复盘：快速分辨“任务不稳定”还是“资源不足”，沉淀成功率/耗时指标；
- 低接入成本：业务以 Task 形式提交即可复用调度与容错能力；
- 一套代码适配多场景（高并发/低并发/数据库），运行期可动态调参，落地维护成本低。

---


# 性能监控（Perf SDK）STAR 面试回答

代码位置：packages/sdk-perf/src/perf.ts、packages/sdk-perf/src/advanced-metrics.ts

## S（Situation，场景）
- 业务痛点：
  - 缺乏统一的前端性能观测口径，难以跨应用对比与定位瓶颈（仅有零散埋点或浏览器面板手查）。
  - 仅监控首屏加载，忽视交互流畅度（长任务、TBT、FPS）与运行时退化（内存、网络质量）。
  - 观测对业务有侵入且开销不可控，生产环境担心性能损耗与隐私合规。
- 技术约束：
  - 需在浏览器环境轻量运行，兼容多浏览器与降级场景；对老页面最小改造即可接入。
  - 指标采样与异步处理，确保监控对业务性能影响可控。

## T（Task，目标）
- 建立“可对比、可复盘”的统一性能指标体系：Web Vitals + 导航/资源加载 + 高级交互与系统指标。
- 低侵入、低开销：通过采样、惰性初始化与解耦上报，避免影响业务关键路径。
- 高可用与可扩展：模块化开关（高级指标、内存泄漏、关键渲染路径），可按需启用。
- 易用性：提供简单 API（init/onMetric/mark/measure），配合阈值分级与类型提示。

## A（Action，行动/方案）
- 指标覆盖：
  - Web Vitals：LCP、CLS、FID、FCP、TTFB 动态引入采集，统一回调输出。
  - PerformanceObserver：导航分段（DNS/TCP/TTFB/DCL/Load）、资源加载、长任务、内存使用等全面采集。
  - 高级指标：
    - FPS 实时监控（requestAnimationFrame 循环、丢帧统计）。
    - 交互时延：首输入延迟、持续交互性、长任务阻塞分析（>50ms）。
    - 环境维度：NetworkInformation（类型、带宽、RTT）与设备信息（CPU 核心、内存、屏幕）。
    - 生命周期：可见性变更、加载/卸载/冻结/恢复，统一埋点时序。
  - 用户自定义：User Timing API 封装（mark/measure/clear），支持复杂业务流程测量。
- 开销与合规：
  - 采样率控制（默认 0.1），异步处理与去抖聚合，避免主线程抖动；敏感字段白名单化。
  - 按需启用高级模块，提供统一清理函数，确保监听器与循环可释放，避免内存泄漏。
- 易集成：
  - 类型安全输出 PerfMetric 与阈值配置 PerfThresholds；与平台遥测对接时解耦合上报（可通过回调对接批量上报）。

## R（Result，结果/价值）
- 指标体系从“开发者各说各话”统一到“平台口径”，跨项目可比，问题定位更快。
- 关键路径与交互流畅度均可量化（LCP/TBT/FPS/长任务占比），形成优化闭环与SLO基线。
- 在默认采样率与异步处理下，对页面 CPU/内存的额外开销可控，生产可安全启用；多浏览器覆盖良好。

---

# 实时通信（Realtime SDK）STAR 面试回答

代码位置：packages/sdk-realtime/src/realtime.ts、packages/sdk-realtime/src/index.ts

## S（Situation，场景）
- 业务痛点：
  - 运营面板、通知系统与协作场景需要稳定的实时链路，但网络抖动、移动网络切换、服务端故障导致断连与消息丢失。
  - 多标签页同时建立连接造成资源浪费与状态竞态；消息有序性与去重缺乏统一保障。
- 技术约束：
  - 浏览器端需在 Socket.IO 之上实现更强的“可靠层”，覆盖断线重连、心跳保活、ACK 确认与序列号有序。

## T（Task，目标）
- 提供“生产级”的可靠实时通道：心跳、自动重连（指数退避）、消息 ACK、序列保证。
- 统一的发布/订阅与权限模型：频道级订阅、发布回执、与后端权限校验配合。
- 跨标签页协调：避免多连接抢占与重复订阅，降低资源开销。
- 可观测与易用：暴露连接状态、重连次数、消息统计；提供类型安全的事件模型。

## A（Action，行动/方案）
- 连接管理：
  - Socket.IO 基础上封装 Realtime.init，完成认证握手、命名空间与传输策略；心跳定时器 + 服务器 heartbeat_ack 校验。
  - 自动重连：支持最大次数、指数退避（base/cap），状态机区分 connecting/reconnecting/disconnected。
  - 回退策略：首次连接失败时可进入本地 loopback 演示模式，保障开发/演示可用性。
- 消息可靠性：
  - 发布/订阅 API：订阅回调分发；发布支持 ackRequired，客户端维护 pendingAcks 映射与超时清理。
  - 序列号与有序性：事件携带 seq 序号，确保同一 topic 内的消息按序处理；接收路径做幂等保护。
  - 队列与背压：在未连通/重连中缓冲待发消息，超过阈值丢弃或告警；上线文可配置 maxQueueSize。
- 跨标签页与权限：
  - 通过浏览器原语（如 BroadcastChannel/localStorage 协调）避免多 Tab 重复连接，复用唯一通道与订阅。
  - 与后端 ChannelPermissions/RealtimeAPI（经 HTTP SDK 暴露）打通，建立频道级权限与统计查询。
- 开发体验：
  - 全量 TypeScript 类型（SocketClientEvents/ServerEvents、消息模型）、debug 日志与状态订阅回调。

## R（Result，结果/价值）
- 在弱网/切网场景下，自动重连成功率与恢复时延显著优化，消息丢失率降低；队列缓冲避免关键事件丢投。
- 多标签页下连接数下降，服务端与客户端资源占用降低；频道权限统一后，接入成本与出错率下降。
- 统一的消息模型与回执语义，便于链路追踪与问题复盘，支撑通知、看板、协作等多场景复用。

---

# 网络请求（HTTP SDK）STAR 面试回答

代码位置：packages/sdk-http/src/client.ts、packages/sdk-http/src/index.ts、packages/sdk-http/README.md（插件示例）

## S（Situation，场景）
- 业务痛点：
  - 各应用分散管理 Axios/Fetch 配置，重试/超时/鉴权/限流缺乏统一策略，导致偶发失败与雪崩放大。
  - 相同请求并发重复发送、错误口径不一、缺少耗时统计与全链路遥测对接。
- 技术约束：
  - 需与现有平台无缝集成，统一错误模型、可插拔扩展，兼顾浏览器与 Node 侧使用。

## T（Task，目标）
- 提供统一可治理的 HTTP 客户端单例：超时、重试、熔断、限流、去重、认证、遥测一体化。
- 插件化：beforeRequest/afterResponse/onError 链路可扩展，满足不同业务定制。
- 可观测：拦截器统一统计请求耗时、状态码与错误类型；与平台遥测数据对齐。
- 易迁移：保留直观的 http.get/post 等 API，最小化业务改造成本。

## A（Action，行动/方案）
- 架构与拦截器：
  - 单例 Axios 实例，request/response 拦截器注入 __startTime 计算 duration，统一暴露到响应对象。
  - 统一错误类 HttpError 与标准化错误类型，屏蔽底层实现差异。
- 插件系统：
  - 认证插件：基于 tokenProvider 动态注入 Authorization，支持 onTokenExpired 刷新回调。
  - 重试插件：基于 @platform/sdk-core 的 withRetry，支持次数、退避策略与条件判定（仅 5xx/网络错误等）。
  - 熔断器插件：失败阈值/重置窗口/状态回调，保护下游服务；
  - 限流插件：按窗口/速率限制请求，缓解瞬时流量尖刺；
  - 去重插件：可配置 keyGenerator 与缓存时间，GET 场景避免并发重复请求；
  - 遥测/Mock 插件：请求指标与日志采集、开发态模拟返回，提升可观测与可测试性。
- API 聚合：
  - 暴露 BMTAPI 统一访问认证/遥测/配置/健康/实时通信管理端接口，简化上层集成；
  - 可配置 baseURL/timeout/headers/validateStatus，适配多环境。

## R（Result，结果/价值）
- 请求治理从“分散/不可控”升级为“统一/可配置”，重复请求与级联失败明显减少，后端稳定性提升。
- 错误模型与耗时统计统一，便于横向对比与问题定位；与遥测贯通后可形成端到端可观测。
- 业务迁移成本低，逐步将零散的 axios/fetch 调用收敛到统一客户端，提升一致性与可维护性。