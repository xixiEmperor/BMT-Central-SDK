# Perf-SDK 性能优化记录

## 优化1：CLS和LCP的重复上报问题

### 问题背景
我们在使用PerformanceObserver的时候是要传入一个回调函数的对吧，这个回调函数据我观察应该是一旦监控的对象发生变化就会触发一次回调，那么在监控CLS，LCP这种持续变化的数据的时候就会有问题，就是可能数据还没变化完，就触发了回调，我们拿到的就不是最终结果，如果是开发阶段还好，那如果是要进行埋点上报，就会导致数据分析错误。

### 核心问题
1. **LCP会持续更新**：在页面加载过程中，LCP会随着更大的内容元素出现而多次触发回调
2. **CLS会持续累积**：在整个页面生命周期中，CLS会持续监测并累积布局偏移
3. **过早上报导致数据不准确**：如果每次回调都上报，会产生大量中间值，影响数据分析的准确性

### 解决方案

#### LCP的处理策略
采用**"事件驱动的最终值上报"**机制：

```typescript
// 核心思路
let lcpValue = 0 // 在回调中持续更新最新值
let reported = false // 防止重复上报

// PerformanceObserver回调只负责更新值，不上报
const observer = new PerformanceObserver((list) => {
  const lastEntry = entries[entries.length - 1]
  if (lastEntry) {
    lcpValue = lastEntry.startTime // 持续更新，不上报
  }
})

// 在明确的时机点上报最终值
const reportLCP = () => {
  if (reported) return
  reported = true
  onMetric?.({ name: 'LCP', value: lcpValue, ... })
  observer.disconnect()
}

// LCP会在以下时机确定最终值：
// 1. 用户首次交互（click, keydown, pointerdown）
// 2. 页面隐藏（visibilitychange）
// 3. 页面卸载（pagehide）
addEventListener('click', reportLCP, { once: true, capture: true })
addEventListener('visibilitychange', reportLCP)
addEventListener('pagehide', reportLCP)
```

**核心原理**：
- LCP在用户首次交互时停止更新（Google Web Vitals规范）
- 利用浏览器事件机制判断最终时机
- 避免使用setTimeout等不确定的延迟方案

#### CLS的处理策略
采用**"持续累积 + 最终值上报"**机制（与 LCP 策略一致）：

```typescript
let clsValue = 0
let reported = false

const observer = new PerformanceObserver((list) => {
  if (reported) return // 已上报最终值，停止处理
  
  // 累积CLS值（只累积，不上报）
  for (const entry of list.getEntries()) {
    if (!entry.hadRecentInput) {
      clsValue += entry.value
    }
  }
  // 注意：这里只累积值，不上报，等待页面隐藏或卸载时再上报最终值
})

// 在页面卸载时上报最终值
const reportFinalCLS = () => {
  if (reported) return
  reported = true
  onMetric?.({ 
    name: 'CLS', 
    value: clsValue,
    ... 
  })
  observer.disconnect()
}

addEventListener('visibilitychange', reportFinalCLS)
addEventListener('pagehide', reportFinalCLS)
```

**核心原理**：
1. **持续累积**：PerformanceObserver 回调只负责累积值，不进行上报
2. **最终值上报**：页面隐藏/卸载时一次性上报最终值
3. **策略统一**：与 LCP 采用相同的策略，代码更一致

### 对比分析

| 指标 | 特点 | 上报策略 | 关键事件 |
|-----|------|---------|---------|
| **LCP** | 会停止更新 | 事件驱动的一次性上报 | 用户首次交互、页面隐藏 |
| **CLS** | 持续累积 | 页面结束时一次性上报 | 页面隐藏、页面卸载 |

**关键区别**：
- LCP 在**用户首次交互**时就确定最终值（因为交互后不再更新）
- CLS 需要等到**页面隐藏/卸载**时才能确定最终值（因为会持续累积）

### 技术要点

1. **避免使用Map维护状态**：使用闭包中的变量（`lcpValue`、`clsValue`）更简洁
2. **利用浏览器事件判断时机**：比setTimeout更准确可靠
3. **使用`{ once: true }`**：确保事件监听器只触发一次，自动移除（LCP 使用）
4. **使用`capture: true`**：在捕获阶段监听，确保优先触发（LCP 使用）
5. **策略统一**：LCP 和 CLS 都采用"只累积，不中间上报"的策略

### 优势
- ✅ 符合 Google Web Vitals 官方规范
- ✅ 准确上报最终值，数据分析更可靠
- ✅ 代码简洁，无需额外的Map映射
- ✅ 利用浏览器原生事件机制，性能更好
- ✅ 防止内存泄漏（及时disconnect）

### 参考资料
- [Web Vitals 官方文档](https://web.dev/vitals/)
- [PerformanceObserver API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver)

---

## 待优化项

3. FCP和FP在paint条目中易混淆